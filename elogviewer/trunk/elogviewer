#!/usr/bin/env python

_debug         = False

__author__     = 'Mathias Laurin <mathias_laurin@users.sourceforge.net>'
__documenter__ = 'Christian Faulhammer <opfer@gentoo.org>'
__artists__    = 'elogviewer needs a logo, \nartists are welcome to contribute, \nplease contact the author.\n' + __author__
__appname__    = 'elogviewer'
__version__    = '0.5.1'
__website__    = 'http://sourceforge.net/projects/elogviewer'
__copyright__  = 'Copyright (c) 2006 ' + __author__
__license__    = 'GNU General Public License (GPL) version 2'


__LICENSE__    = __copyright__ + '''

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.'''


__description__ = '''elogviewer lists all elogs created during emerges of
packages from Portage, the package manager of Gentoo Linux.  So all
warnings or informational messages generated during an update can be
reviewed at one glance.

man 1 elogviewer and man 1 /etc/make.conf for more informations.

Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.
Christian Faulhammer (V-Li) has written the man page.'''


try:
	import pygtk
	pygtk.require ( '2.0' )
except:
	print "Please run: emerge --sync && emerge pygtk"

import gtk
from   gobject  import TYPE_STRING, TYPE_PYOBJECT
import portage
import os
import time
import re

### Redirect any message from sdtout to stderr
from sys     import stdout, stderr
stdout = stderr

if _debug:
	print 'running debug mode'
	os.chdir( "elog" )
else:
	try:
		os.chdir( portage.settings["PORT_LOGDIR"] )
	except:
		os.chdir( "/var/log/portage" )
	try:
		os.chdir( "./elog" )
	except:
		print '''
Please install the elog feature as explained in the ebuild and
in /etc/make.conf.example
you should have at least one of 
	PORTAGE_ELOG_CLASSES="info warn error log"
and
	PORTAGE_ELOG_SYSTEM="save"
in your /etc/make.conf
		'''

class ScrolledWindow (gtk.ScrolledWindow):
	def __init__ (self):
		gtk.ScrolledWindow.__init__ (self)
		self.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )

class FileList (gtk.TreeView):

		def __init__ (self, selection_handler):

			col_headers = [ "Category", "Package", "Timestamp" ]
			model = gtk.ListStore(TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_PYOBJECT)
			gtk.TreeView.__init__ (self, model)

			self.model = model
			#self.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

			for c in range( len(col_headers) ):
				cell = gtk.CellRendererText()
				col  = gtk.TreeViewColumn(col_headers[c], cell, text=c)
				col.set_sort_column_id( c )
				self.append_column(col)

			### Selection handler
			self.get_selection().connect_object('changed', selection_handler, None)

		def populate (self):
			for filename in os.listdir( os.getcwd() ):
				log = self.split_colon(filename)
				self.model.append( log )

		def split_colon (self, filename):
			intimeformat  = "%Y%m%d-%H%M%S.log"
			outtimeformat = "%Y-%m-%d %H:%M:%S"

			(c, p, t) = re.split( ":", str(filename) )
			t = time.strptime( t, intimeformat  )
			t = time.strftime( outtimeformat, t )

			return [c, p, t, filename]

class LogView (gtk.TextView):
		def __init__ (self):
			gtk.TextView.__init__ (self)
			self.set_editable (False)
			self.set_cursor_visible (False)
			self.set_wrap_mode (gtk.WRAP_WORD)

		### Probably better in its own class...
		def strip_nl (self, line):
			return re.match( r'^([^\\\n]*)', line ).group( 1 )

		### Should not receive filename! that is bad object-oriented prog
		def set_text (self, filename=None):
			
			### Init buffer
			N_COLORS      = 16
			buffer        = self.get_buffer()
			buffer.set_text ('')
			# text color from gtk.TexTag - gtk.TextTagTable

			### local header list
			header_labels = ''
			for h in Filter.header.keys():
				if header_labels == '':
					header_labels = h
				else:
					header_labels = header_labels + '|' + h
			header_labels = re.compile( header_labels )

			### Read the file
			file      = open( filename, 'r' )
			readline  = ''
			firstline = True
			for readline in file:
				readline = self.strip_nl (readline)

				### is section?
				if header_labels.match (readline):
					line = readline.split( ': ' )
					h    = line[0]
					s    = line[1]
					if firstline:
						firstline = False
					else:
						buffer.insert_at_cursor ('\n')

					buffer.insert_at_cursor ('%s (%s)\n' % (h, s))

				### filter section content?
				elif Filter.header[h] and Filter.stage[s]:
					buffer.insert_at_cursor ( '%s\n' % readline)

class Filter(gtk.VBox):

		header = { "INFO": bool(), "WARN": bool(), "ERROR": bool(), "LOG": bool() }
		stage  = { "preinst": bool(), "postinst": bool(), \
					"postrm": bool(), "prerm": bool(), \
					"unpack": bool(), \
					"compile": bool(), "setup": bool(), "test": bool(), "install": bool(), \
					"other": bool()}
	
		def __init__ (self):
			gtk.VBox.__init__ (self)
			separator = gtk.HSeparator()

			headerbox = self.get_box(self.header)
			self.pack_start (headerbox, False)
			self.pack_start (separator, False)
			stagebox  = self.get_box(self.stage)
			self.pack_start (stagebox, False)

		### NOTE: won't work on odd number of stage/header
		### fix it if ever it happens someday:
		### a dummy box that is not shown would do
		def get_box(self, dict):
			box = gtk.Table(len(dict)/2, 2, True)
			btn = {}
			row = 0
			col = 0
			for label in dict.keys():
				btn[label]   = gtk.CheckButton( label, False )
				btn[label].set_active(True)
				dict[label]  = True
				btn[label].connect( "toggled", self.toggle, dict, label )
				box.attach(btn[label], col, col+1, row, row+1)
				col += 1
				if col == 2:
					col  = 0
					row += 1
			return box

		def toggle(self, btn, dict, label):
			dict[label] = not dict[label]
			#LogView.set_text()
			
class Actions(gtk.UIManager):

		def __init__ (self, delete, clear, refresh, quit):
			gtk.UIManager.__init__ (self)

			ui = '''<ui>
			<menubar name="Menubar">
				<menu action="File">
					<menuitem action="Delete"/>
					<menuitem action="Clear"/>
					<menuitem action="Refresh"/>
					<separator/>
					<menuitem action="Quit"/>
				</menu>
				<menu action="Help">
					<menuitem action="Info"/>
					<menuitem action="About"/>
				</menu>
			</menubar>
			<toolbar name="Toolbar">
				<toolitem action="Quit"/>
				<toolitem action="Delete"/>
				<toolitem action="Clear"/>
				<toolitem action="Refresh"/>
			</toolbar>
			</ui>'''

			### Actually build the UI
			action_group = gtk.ActionGroup('Main')
			action_group.add_actions([
			('File',    None, '_File'),
			('Help',    None, '_Help'),
			('About',   None, '_About...',          None, None,          self.about_box     ),
			('Info',    None, '_Info',              None, None,          self.info_box      ),
			('Quit',    gtk.STOCK_QUIT,   '_Quit',   'q', 'Quit',        quit),
			('Delete',  gtk.STOCK_DELETE, '_Delete', 'd', 'Delete selected entry', delete),
			('Clear',   gtk.STOCK_CLEAR,  '_Clear',  'c', 'Clear all',   clear),
			('Refresh', gtk.STOCK_REFRESH,'_Refresh','r', 'Refresh',     refresh)])
			
			self.insert_action_group(action_group, 0)
			self.add_ui_from_string(ui)

			### extract widgets
			self.menubar     = self.get_widget('/Menubar')
			self.toolbar     = self.get_widget('/Toolbar')
			self.accel_group = self.get_accel_group()

		def about_box (self, *args):
			d = gtk.AboutDialog()
			d.set_version( __version__ )
			d.set_website( __website__ )
			d.set_authors( [__author__, 'Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.'] )
			d.set_artists( [__artists__] )
			d.set_copyright( __copyright__ )
			d.set_documenters( [__documenter__, __author__] )
			d.set_license( __LICENSE__ )
			d.run()
			d.destroy()

		def info_box (self, *args):
			d = gtk.MessageDialog(None, 0, gtk.MESSAGE_INFO, gtk.BUTTONS_OK, None)
			d.set_markup ( __description__ )
			d.run()
			d.destroy()

class Statusbar (gtk.Statusbar):
		def __init__ (self):
			gtk.Statusbar.__init__(self)

class Elogviewer (gtk.Window):
		def destroy (self, *args):
			gtk.main_quit()
	
		def __init__ (self):
			### Initialize main window
			gtk.Window.__init__ (self, gtk.WINDOW_TOPLEVEL)
			self.set_title( __appname__ )
			self.connect( "destroy", lambda w: self.destroy() )
			self.set_default_size( 800, 600 )
			self.show()

			### Initialize widgets
			actions  = Actions  (self.delete, self.clear, self.refresh, self.destroy)
			filelist = FileList (self.selection_change)
			filter   = Filter()
			logview  = LogView()
			statusbar= Statusbar()
			pane     = gtk.VPaned()

			### Accelerators
			self.add_accel_group(actions.accel_group)

			### Box for packing widgets
			rootbox      = gtk.VBox (False, 0)
			self.add(rootbox)
			self.rootbox = rootbox

			rootbox.pack_start(actions.menubar, False)
			rootbox.pack_start(actions.toolbar, False)
			rootbox.pack_start(pane) 
			rootbox.pack_start(statusbar, False)
			rootbox.show()

			### Main window/VPaned
			scfilelist = ScrolledWindow()
			scfilelist.add (filelist)
			pane.pack1  (scfilelist, True)

			_botbox    = gtk.HBox()
			sclogview  = ScrolledWindow()
			sclogview.add(logview)
			_botbox.pack_start(sclogview, True)
			_botbox.pack_start(filter,   False)
			pane.pack2  (_botbox, True)

			pane.show_all()

			### Export
			self.filelist  = filelist
			self.selection = filelist.get_selection().get_selected
			self.logview   = logview

			### Populate!
			filelist.populate()

			### Export
			self.filelist  = filelist
			self.selection = filelist.get_selection()
			self.logview   = logview

		### Actions
		def selection_change (self, *args):
			try:
				[model,iter] = self.selection.get_selected()
				filename = model.get_value(iter,3)
				self.logview.set_text(filename)
			except:
				pass

		def delete (self, *args):
			[model,iter]    = self.selection.get_selected()
			if iter is None:
				# No selection
				return False
			path            = model.get_path(iter)
			filename        = model.get_value(iter,3)

			model.remove (iter)
			if _debug:
				print filename
			else:
				os.remove (filename)

			if model.iter_is_valid(iter):
				self.selection.select_iter(iter)
			else:
				# Last in the list?
				# select last but one but not if list is empty
				newpath = (path[0]-1,)
				if newpath != (-1,):
					self.selection.select_path(newpath)

		def clear (self, *args):
			button = gtk.BUTTONS_YES_NO
			dialog = gtk.MessageDialog(None, 0, gtk.MESSAGE_WARNING, button, \
				"The whole elog directory is going to be wiped out.\nAre you sure you want to proceed?")
			clear = dialog.run()
			dialog.destroy()

			if clear == gtk.RESPONSE_YES:
				self.selection.select_path(0)
				while self.selection.path_is_selected(0):
					self.delete()


		def refresh(self, *args):
			self.filelist.populate()


def main():
		gtk.main()
		return 0

if __name__ == "__main__":
		Elogviewer()
		main()

### Refs
# http://www.javaworld.com/jw-07-1999/jw-07-toolbox.html
