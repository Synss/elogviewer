#!/usr/bin/env python

_debug         = False

_author     = 'Mathias Laurin <mathias_laurin@users.sourceforge.net>'
_documenter = 'Christian Faulhammer <opfer@gentoo.org>'
_artists    = 'elogviewer needs a logo, \nartists are welcome to contribute, \nplease contact the author.\n' + _author
_appname_    = 'elogviewer'
_version    = '0.5.1'
_website    = 'http://sourceforge.net/projects/elogviewer'
_copyright  = 'Copyright (c) 2006 ' + _author
_license    = 'GNU General Public License (GPL) version 2'


_LICENSE    = _copyright + '''

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.'''


_description = '''
<b>elogviewer</b> lists all elogs created during emerges of packages from Portage, the package manager of Gentoo Linux.  So all warnings or informational messages generated during an update can be reviewed at one glance.

<tt>man 1 elogviewer</tt> and <tt>man 1 /etc/make.conf</tt> for more informations.

Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.
Jeremy Wickersheimer adapted elogviewer to KDE, some features he added are now imported in elogviewer.
Christian Faulhammer (V-Li) has written the man page.
'''


try:
	import pygtk
	pygtk.require('2.0')
except:
	print "Please run: emerge --sync && emerge pygtk"

import gtk
from   gobject  import TYPE_STRING, TYPE_PYOBJECT
import portage
import os
import time
import re

### Redirect any message from sdtout to stderr
from sys     import stdout, stderr
stdout = stderr

if _debug:
	print 'WARNING: Running debug mode'
	os.chdir("elog")
else:
	try:
		os.chdir(portage.settings["PORT_LOGDIR"])
	except:
		os.chdir("/var/log/portage")
	try:
		os.chdir("./elog")
	except:
		print '''
Please install the elog feature as explained in the ebuild and
in /etc/make.conf.example
you should have at least one of 
	PORTAGE_ELOG_CLASSES="info warn error log"
and
	PORTAGE_ELOG_SYSTEM="save"
in your /etc/make.conf
		'''


(
	CATEGORY_COLUMN,
	PACKAGE_COLUMN,
	TIMESTAMP_COLUMN,
	FILENAME_COLUMN
) = range(4)


class MainWindow (gtk.Window):
		
		def __init__ (self):
			gtk.Window.__init__ (self, gtk.WINDOW_TOPLEVEL)
			self.set_title( _appname_ )
			self.set_default_size( 800, 600 )


class ScrolledWindow (gtk.ScrolledWindow):

	def __init__ (self, child):
		gtk.ScrolledWindow.__init__ (self)
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		self.add (child)


class Header:

		def __init__(self, name, color='black', is_section=False, is_active=True):
			self.name = name
			self.color = color
			self.is_section = is_section
			self.is_active = is_active


class HeaderList:
		'''Initialize the values for the filter '''
		def __init__(self):
			self.INFO = Header('INFO', 'darkgreen', True)
			self.WARN = Header('WARN', 'red', True)
			self.ERROR= Header('ERROR', 'orange', True)
			self.LOG  = Header('LOG', 'black', True)

			self.preinst = Header('preinst')
			self.postinst= Header('postinst')
			self.postrm  = Header('postrm')
			self.prerm   = Header('prerm')
			self.unpack  = Header('unpack')
			self.compile = Header('compile')
			self.setup   = Header('setup')
			self.test    = Header('test')
			self.install = Header('install')
			self.other   = Header('other')

		# Call the dictionary dictionary
		# I love python
		def keys(self):
			return self.__dict__.keys()

		def values(self):
			return self.__dict__.values()

		def is_active(self, name):
			return self.__dict__[name].is_active

		def section(self):
			list = []
			for value in self.__dict__.values():
				if value.is_section:
					list.append(value)
			return list

		def stage(self):
			list = []
			for value in self.__dict__.values():
				if not value.is_section:
					list.append(value)
			return list


class ChkBtnTable(gtk.Table):

		def __init__ (self, list, selection_changed):
			tcol = 2
			trow = len(list)/tcol	# won't work on odd numbers
			gtk.Table.__init__ (self, trow, tcol, True)

			self.selection_changed = selection_changed

			btn = {}
			row = 0
			col = 0

			for hlist in list:
				btn[hlist.name] = gtk.CheckButton(hlist.name, False)
				btn[hlist.name].set_active(hlist.is_active)
				btn[hlist.name].connect('toggled', self.toggle, hlist)
				self.attach(btn[hlist.name], col, col+1, row, row+1)
				col += 1
				if col == tcol:
					col  = 0
					row += 1

		def toggle(self, btn, header):
			header.is_active = not header.is_active
			# emit may be better
			self.selection_changed()


class LogEntry:

		def __init__ (self, filename='c:p:t.log'):
			intimeformat  = '%Y%m%d-%H%M%S.log'
			outtimeformat = '%Y-%m-%d %H:%M:%S'

			(c, p, t) = re.split(':', str(filename))
			t = time.strptime (t, intimeformat)
			t = time.strftime (outtimeformat, t)

			self.category = c
			self.package  = p
			self.timestamp= t
			self.filename = filename


class ModelSelector (gtk.HBox):
		'''Two buttons for selecting the model'''
		def __init__ (self, action):
			gtk.HBox.__init__(self)
			self.btn_liststore = gtk.RadioButton(None, 'List')
			self.btn_treeview  = gtk.RadioButton(self.btn_liststore, 'Tree view')
			self.btn_treeview.connect('toggled', action)
			self.add(self.btn_liststore)
			self.add(self.btn_treeview)


class Model:

		def __init__ (self):
			liststore = gtk.ListStore (TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_PYOBJECT)
			liststore.set_sort_column_id(TIMESTAMP_COLUMN, gtk.SORT_DESCENDING)
			self.liststore = liststore
			
			treestore = gtk.TreeStore (TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_PYOBJECT)
			self.treestore = treestore

		def populate (self):
			self.treestore.clear()
			self.liststore.clear()
			for filename in os.listdir(os.getcwd()):
				log  = LogEntry(filename)
				### Liststore
				self.liststore.append([log.category, log.package, 
								log.timestamp, log.filename])
				### Treestore looks simple now.
				iter = self.treestore.get_iter_first()
				_loop = True
				while _loop:
					if iter is None:
						_newcategory = True
						_loop = False
					else:
						category = self.treestore.get_value(iter, CATEGORY_COLUMN)
						if category == log.category:
							self.treestore.append(iter, ['', 
									log.package, log.timestamp, log.filename])
							_newcategory = False
							_loop = False
						iter = self.treestore.iter_next(iter) 
				if _newcategory:
					iter = self.treestore.append(None, [log.category, '', '', ''])
					self.treestore.append(iter, ['', 
							log.package, log.timestamp, log.filename])


class FileList (gtk.TreeView):

		def __init__ (self, selection_handler):

			col_headers = ['Category', 'Package', 'Timestamp']
			gtk.TreeView.__init__ (self)
			self.set_enable_search(True)
			self.set_search_column(PACKAGE_COLUMN)
			#self.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
			model  = Model()
			self.model = model

			for c in range(len(col_headers)):
				cell = gtk.CellRendererText()
				col  = gtk.TreeViewColumn(col_headers[c], cell, text=c)
				col.set_sort_column_id(c)
				self.append_column(col)

			# Selection handler
			self.get_selection().connect_object('changed', selection_handler, None)

		#def populate shortcut
			self.populate = model.populate

		def get_n_files(self):
			return len(self.model.liststore)

		def get_n_categories(self):
			return len(self.model.treestore)

		# Now, everything the is relevant to selection
		def get_selected(self):
			return self.get_selection().get_selected()

		def select_first(self):
			self.get_selection().select_path(0)
			bool = self.get_selection().path_is_selected(0)
			return bool	# Return True if successful

		def get_filename(self):
			[model, iter] = self.get_selected()
			if iter is None:	# No selection
				return ''
			filename = model.get_value(iter, FILENAME_COLUMN)
			if filename is '':	# Root selected
				if _debug:
					print self, 'Root selected'
			return filename

		def select_iter(self, iter):
			niter = self.get_selection().selectiter(iter)
			return niter

		#def get_mif(self):
		#	filename = self.get_filename()
		#	[model, iter] = self.get_selected()
		#	return model, iter, filename


class Buffer (gtk.TextBuffer):
		
		def __init__ (self, headerlist):
			gtk.TextBuffer.__init__ (self)
			self.set_text('No selection')
			for n in headerlist.section():
				tag = self.create_tag(n.name, foreground=n.color)


class LogView (gtk.TextView):

		def __init__ (self, headerlist):
			gtk.TextView.__init__ (self)
			self.set_editable (False)
			self.set_cursor_visible (False)
			self.set_wrap_mode (gtk.WRAP_WORD)

			self.buffer = Buffer(headerlist)
			self.set_buffer (self.buffer)
			
			# WARNING: potentially dangerous to have the regexp matching over 
			# stages
			self.reheaderlist= self.__make_re_list(headerlist.keys())
			self.headerlist  = headerlist

		def __make_re_list (self, list):
			relist = 'empty'
			for n in list:
				if relist == 'empty':
					relist = n
				else:
						relist = relist + '|' + n
				relist = relist + ': '
			relist = re.compile(relist)
			return relist

		def __strip_nl (self, line):
			return re.match(r'^([^\\\n]*)', line).group(1)

		def set_text (self, filename=''):
			self.buffer.set_text('')
			if filename is '':
				return
			### Read the file
			file      = open(filename, 'r')
			firstline = True
			for readline in file:
				readline = self.__strip_nl(readline)
				### is section?
				if self.reheaderlist.match(readline):
					(section, stage) = readline.split(': ')
					if firstline:
						firstline = False
					#elif readline is '':	# Skip empty lines
					#	pass
					else:
						self.buffer.insert_at_cursor ('\n')
					
					line = '%s (%s)\n' % (section, stage)
					iter = self.buffer.get_end_iter()
					self.buffer.insert_with_tags_by_name(iter, line, section)

				### filter content?
				elif self.headerlist.is_active(section) and \
							self.headerlist.is_active(stage):
						line = '%s\n' % readline
						iter = self.buffer.get_end_iter()
						self.buffer.insert_with_tags_by_name(iter, line, section)


class About(gtk.AboutDialog):
		def __init__(self):
			gtk.AboutDialog.__init__(self)
			self.set_version( _version )
			self.set_website( _website )
			self.set_authors( [_author, 'Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.'] )
			self.set_artists( [_artists] )
			self.set_copyright( _copyright )
			self.set_documenters( [_documenter, _author] )
			self.set_license( _LICENSE )
			self.run()
			self.destroy()


class Info(gtk.MessageDialog):
		def __init__(self):
			gtk.MessageDialog.__init__(self, 
					None, 0, gtk.MESSAGE_INFO, gtk.BUTTONS_OK, None)
			self.set_markup ( _description )
			self.run()
			self.destroy()


class Actions(gtk.UIManager):

		def __init__ (self, delete, clear, refresh, quit):
			gtk.UIManager.__init__ (self)

			ui = '''<ui>
			<menubar name="Menubar">
				<menu action="File">
					<menuitem action="Delete"/>
					<menuitem action="Clear"/>
					<menuitem action="Refresh"/>
					<separator/>
					<menuitem action="Quit"/>
				</menu>
				<menu action="Help">
					<menuitem action="Info"/>
					<menuitem action="About"/>
				</menu>
			</menubar>
			<toolbar name="Toolbar">
				<toolitem action="Quit"/>
				<toolitem action="Delete"/>
				<toolitem action="Clear"/>
				<toolitem action="Refresh"/>
			</toolbar>
			</ui>'''

			action_group = gtk.ActionGroup('Main')
			action_group.add_actions([
			('File',    None, 'File'),
			('Help',    None, 'Help'),
			('About',   None, 'About...', None, None, self.about),
			('Info',    None, 'Info',     None, None, self.info),
			('Quit',    gtk.STOCK_QUIT,   'Quit',   '<Control>q', 'Quit <Ctrl+q>', quit),
			('Delete',  gtk.STOCK_DELETE, 'Delete', '<Control>d', 'Delete selected entry <Ctrl+d>', 
					delete),
			('Clear',   gtk.STOCK_CLEAR,  'Clear',  '<Control>c', 'Clear all <Ctrl+c>', clear),
			('Refresh', gtk.STOCK_REFRESH,'Refresh','<Control>r', 'Refresh <Ctrl+r>', refresh)
			])
			
			self.insert_action_group(action_group, 0)
			self.add_ui_from_string(ui)

			### Extract widgets
			self.menubar     = self.get_widget('/Menubar')
			self.toolbar     = self.get_widget('/Toolbar')
			self.accel_group = self.get_accel_group()

		def about(self, *args):
			About()

		def info(self, *args):
			Info()


class Statusbar (gtk.Statusbar):

		def __init__ (self):
			gtk.Statusbar.__init__(self)

		def update(self, text):
			self.push(0, text)


class Elogviewer:
		
		def __init__ (self):
			# Initialize widgets
			self.headerlist = HeaderList()
			self.actions  = Actions(self.delete, self.clear, self.refresh, self.destroy)
			self.filelist = FileList(self.selection_changed)
			self.logview  = LogView(self.headerlist)
			self.statusbar= Statusbar()
			self.modelselector = ModelSelector(self.set_model)

			gui = self.__build_GUI()
			gui.add_accel_group(self.actions.accel_group)
			gui.show_all()

			# Connect button
			self.modelselector.btn_treeview.connect('toggled', self.is_treestore)

			self.set_model()
			self.filelist.populate()

			if not _debug:
				self.filelist.select_first()
		
		def __build_GUI(self):
			mainwindow = MainWindow()
			mainwindow.connect("destroy", lambda w: self.destroy())

			rootbox  = gtk.VBox (False, 0)
			rootbox.pack_start(self.actions.menubar, False)
			rootbox.pack_start(self.actions.toolbar, False)
			pane     = gtk.VPaned()
			rootbox.pack_start(pane)
			rootbox.pack_start(self.statusbar, False)
			mainwindow.add(rootbox)

			scfilelist = ScrolledWindow(self.filelist)
			pane.pack1  (scfilelist, True)

			sclogview  = ScrolledWindow(self.logview)

			f_sectionbox = ChkBtnTable(self.headerlist.section(), self.selection_changed)
			f_stagebox   = ChkBtnTable(self.headerlist.stage(),   self.selection_changed)

			filterbox = gtk.VBox(False)
			filterbox.pack_start(f_sectionbox, False)
			filterbox.pack_start(gtk.HSeparator(), False)
			filterbox.pack_start(f_stagebox, False)
			filterbox.pack_start(gtk.HSeparator(), False)
			filterbox.pack_start(self.modelselector, False)

			botbox    = gtk.HBox()
			botbox.pack_start(sclogview, True)
			botbox.pack_start(filterbox, False)

			pane.pack2  (botbox, True)
			return mainwindow

		def destroy(self, *args):
			gtk.main_quit()

		def is_treestore(self, *args):
			return self.modelselector.btn_treeview.get_active()

		def set_model(self, *args):
			bool = self.is_treestore()
			if bool:
				self.filelist.set_model(self.filelist.model.treestore)
			else:
				self.filelist.set_model(self.filelist.model.liststore)

		def selection_changed (self, *args):
			filename = self.filelist.get_filename()
			[model, iter] = self.filelist.get_selected()
			self.logview.set_text(filename)
			self.update_statusbar()

		def update_statusbar(self, *args):
			tot_files = self.filelist.get_n_files()
			nb_cat    = self.filelist.get_n_categories()
			filename = self.filelist.get_filename()
			#sel_file  = self.filelist.model.get_path(iter)[0] + 1

			#statusbartext = str(tot_files) + ' files in ' + \
			#	str(nb_cat) + ' categories' + \
			#	'\tSelection: ' + filename
			statusbartext = 'Selection: ' + filename
			self.statusbar.update(statusbartext)
		
		def delete (self, *args):
			# 1. get position and filename
			[model, iter] = self.filelist.get_selected()
			filename = self.filelist.get_filename()
			if filename is '':	# either no selection or tree selected
				return
			path = model.get_path(iter)

			# 2. remove from list and from system
			model.remove(iter)
			if _debug:
				print filename
			else:
				os.remove (filename)

			# 3. select another entry
			# NOTE: Could put all that in Filelist: and select
			# the new one before removing the old one,
			# but I already have everything I need.
			if model.iter_is_valid(iter):
				self.filelist.get_selection().select_iter(iter)
			else:
				bool = self.is_treestore()
				if bool:
					self.__get_next_iter_treestore(model, iter, path)
				else:
					self.__get_next_iter_liststore(model, iter, path)

		def __get_next_iter_treestore(self, model, iter, path):
			if path[1] != 0:	# Not the last element (last is not first)
				# select previous path
				newpath = (path[0],path[1]-1)
				self.filelist.get_selection().select_path(newpath)
				return newpath
			else:
				# Last is first, remove tree and select prev one
				iter = model.get_iter(path[0],)
				model.remove (iter)
				newpath = (path[0]-1,)
				if newpath == (-1,):
					newpath = (0,)
					try:
						self.filelist.get_selection().select_path(newpath)
						return newpath
					except:		# Tree is empty
						return False
				else:
					self.filelist.get_selection().select_path(newpath)
					return newpath

		def __get_next_iter_liststore(self, model, iter, path):
			newpath = (path[0]-1,)
			# select last but one unless list empty
			if newpath != (-1,):
				self.filelist.get_selection().select_path(newpath)
			return newpath
			

		def clear (self, *args):
			button = gtk.BUTTONS_YES_NO
			dialog = gtk.MessageDialog(None, 0, gtk.MESSAGE_WARNING, button, 
				"The whole elog directory is going to be wiped out. Are you sure you want to proceed?")
			clear = dialog.run()
			dialog.destroy()

			if clear == gtk.RESPONSE_YES:
				self.modelselector.btn_liststore.set_active(True)
				while self.filelist.select_first():
					self.delete()

		def refresh(self, *args):
			self.filelist.populate()


def main():
		gtk.main()
		return 0


if __name__ == "__main__":
		Elogviewer()
		main()

### Refs
# http://www.javaworld.com/jw-07-1999/jw-07-toolbox.html
# http://www.pygtk.org/pygtk2reference/
# http://docs.python.org/
