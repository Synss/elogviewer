#!/usr/bin/env python
_debug = True

_author     = ['Mathias Laurin <mathias_laurin@users.sourceforge.net>',
		'Timothy Kilbourn']
_documenter = 'Christian Faulhammer <opfer@gentoo.org>'
_artists    = 'elogviewer needs a logo, \nartists are welcome to contribute, \nplease contact the author.\nMathias Laurin' 
_appname_    = 'elogviewer'
_version    = '0.5.2'
_website    = 'http://sourceforge.net/projects/elogviewer'
_copyright  = 'Copyright (c) 2007 Mathias Laurin'
_license    = 'GNU General Public License (GPL) version 2'


_LICENSE    = _copyright + '''

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.'''


_description = '''
<b>elogviewer</b> lists all elogs created during emerges of packages from Portage, the package manager of Gentoo Linux.  So all warnings or informational messages generated during an update can be reviewed at one glance.

<tt>man 1 elogviewer</tt> and <tt>man 1 /etc/make.conf</tt> for more informations.

Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.
Jeremy Wickersheimer adapted elogviewer to KDE, some features he added are now imported in elogviewer.
Christian Faulhammer (V-Li) has written the man page.
'''


# Redirect messages to stderr
import sys
sys.stdout = sys.stderr

try:
	import gtk
except:
	print '''
Elogviewer should help you not to miss important information like: 

If you have just upgraded from an older version of python you
will need to run:
	/usr/sbin/python-updater

please do run it and restart elogviewer.
'''
	exit(1)

import os
import portage
if _debug:
	print "Debug mode\n"
	os.chdir("elog/elog")
else:
	try:
		os.chdir(portage.settings["PORT_LOGDIR"])
	except:
		os.chdir("/var/log/portage")
	try:
		os.chdir("./elog")
	except:
		print '''
You need to enable the elog feature by setting at least one of 
	PORTAGE_ELOG_CLASSES="info warn error log"
and
	PORTAGE_ELOG_SYSTEM="save"
in /etc/make.conf


Read /etc/make.conf.example for more information
'''
		exit(1)



filter = {'INFO': True, 'WARN': True, 'ERROR': True, 'LOG': True,
		'preinst': True, 'postinst': True, 'prerm': True, 'postrm': True,
		'unpack': True, 'compile': True, 'setup': True, 'test': True,
		'install': True, 'other': True}


class MainWindow (gtk.Window):
		
	def __init__ (self):
		gtk.Window.__init__ (self, gtk.WINDOW_TOPLEVEL)
		self.set_title( _appname_ )
		self.set_default_size( 800, 600 )


class ScrolledWindow(gtk.ScrolledWindow):
	
	def __init__(self):
		gtk.ScrolledWindow.__init__(self)
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)


import time
class Elog:
	
	def __init__(self, filename):

		itime = '%Y%m%d-%H%M%S.log'
		#otime = '%Y-%m-%d %H:%M:%S'
		# see modules time and locale
		otime = '%x %X'

		(c, p, t) = filename.split(':')
		t = time.strptime(t, itime)
		t = time.strftime(otime, t)
		
		self.category = c
		self.package = p
		self.timestamp = t
		self.filename = filename


from glob import glob
class TreeModel:

	def __init__(self):
		#gtk.TreeModel.__init__(self)

		# BUG #187595 (thank you Radice David)
		self.elog = [Elog(filename) for filename in glob('*:*:*.log')]

	def get_filename(self, model, iter):
		if not iter:
			return
		filename = model.get_value(iter, FILENAME)
		if not filename:
			return
		return filename


from gobject import TYPE_STRING
( CATEGORY, PACKAGE, TIMESTAMP, FILENAME ) = range(4)
class ListStore(TreeModel, gtk.ListStore):

	def __init__(self):
		TreeModel.__init__(self)
		gtk.ListStore.__init__( self,
				TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_STRING )
		self.set_sort_column_id(TIMESTAMP, gtk.SORT_DESCENDING)

	def get_iter_last(self):
		iter = self.get_iter_first()
		if not iter:
			return
		iter_next = self.iter_next(iter)
		while iter_next:
			iter_next = self.iter_next(iter)
			iter = iter_next
		return iter

	def populate(self):
		self.clear()
		for e in self.elog:
			self.append((e.category, e.package, e.timestamp, e.filename))

	def delete(self, selection):
		[model, iter] = selection.get_selected()
		filename = self.get_filename(model, iter)
		if not filename:
			return
		try:
			if _debug:
				print filename
			else:
				os.remove(filename)
		except:
			print "failed to remove " + filename + " in " + self
		self.remove(iter)
		if self.iter_is_valid(iter):
			# select same position
			selection.select_iter(iter)
		else:
			# select last in the list
			# unless list is empty
			iter = self.get_iter_last()
			if iter:
				selection.select_iter(iter)


class TreeStore(TreeModel, gtk.TreeStore):

	def __init__(self):
		TreeModel.__init__(self)
		gtk.TreeStore.__init__( self,
				TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_STRING )

	def get_iter_for(self, category):
		iter = self.get_iter_first()
		# FIXME try the foreach thing in
		# http://www.pygtk.org/pygtk2tutorial/sec-TreeModelInterface.html
		while iter:
			if self.get_value(iter, CATEGORY) == category:
				break
			else:
				iter = self.iter_next(iter)
		return iter

	def get_iter_last(self):
		iter = self.get_iter_first()
		if not iter:
			return
		iter_next = self.iter_next(iter)
		while iter_next:
			iter_next = self.iter_next(iter)
			iter = iter_next
		return iter

	def populate(self):
		self.clear()
		for e in self.elog:
			iter = self.get_iter_for(e.category)
			if not iter:
				# New category
				iter = self.insert_before(None, None)
				self.set_value(iter, 0, e.category)
			self.append(iter, (None,
						e.package, e.timestamp, e.filename))

	def delete(self, selection):
		[model, iter] = selection.get_selected()
		filename = self.get_filename(model, iter)
		if not filename:
			return
		try:
			if _debug:
				print filename + " deleted"
			else:
				os.remove(filename)
		except:
			print "failed to remove " + filename + " in " + self
		# FIXME
		# memorizing the path and using refresh should be easier
		self.remove(iter)
		if self.iter_is_valid(iter):
			selection.select_iter(iter)
		else:
			iter = self.get_iter_last()
			if iter:
				selection.select_iter(iter)
		


class TreeView(gtk.TreeView):
	
	def __init__(self):
		gtk.TreeView.__init__(self)

		self.append_column(gtk.TreeViewColumn(
			'Category', gtk.CellRendererText(), text=CATEGORY))
		self.append_column(gtk.TreeViewColumn(
			'Package', gtk.CellRendererText(), text=PACKAGE))
		self.append_column(gtk.TreeViewColumn(
			'Time', gtk.CellRendererText(), text=TIMESTAMP))
		# FIXME next is + elegant but does not work
		# maybe lambda...
		#[ c.set_sort_order(gtk.SORT_DESCENCDING) 
		#		for c in self.get_columns() ]
		for c in range(len(self.get_columns())):
			self.get_column(c).set_sort_column_id(c)
		
		self.set_enable_search(True)
		self.set_search_column(PACKAGE)
		#self.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

	def get_filename(self):
		[model, iter] = self.get_selection().get_selected()
		if not iter:
			# no selection
			return
		filename = model.get_value(iter, FILENAME)
		if not filename:
			return
		if _debug:
			print filename + " selected"
		return filename


class CheckButton(gtk.CheckButton):

	def __init__(self, label=None, use_underline=False):
		gtk.CheckButton.__init__(self, label, use_underline)
		self.set_active(True)


class Table(gtk.Table):

	def __init__(self, rows=2, columns=2, homogeneous=False):
		gtk.Table.__init__(self, rows, columns, homogeneous)


class HeaderTable(Table):

	def __init__(self):
		Table.__init__(self, 2, 2)

		btn_info = CheckButton('INFO')
		btn_warn = CheckButton('WARN')
		btn_error = CheckButton('ERROR')
		btn_log = CheckButton('LOG')

		self.attach(btn_info,  0, 1, 0, 1)
		self.attach(btn_warn,  1, 2, 0, 1)
		self.attach(btn_error, 0, 1, 1, 2)
		self.attach(btn_log,   1, 2, 1, 2)

		# public
		self.btn_info = btn_info
		self.btn_warn = btn_warn
		self.btn_error = btn_error
		self.btn_log = btn_log


class StageTable(Table):

	def __init__(self):
		Table.__init__(self, 2, 5)

		btn_preinst = CheckButton('preinst')
		btn_postinst = CheckButton('postinst')
		btn_prerm = CheckButton('prerm')
		btn_postrm = CheckButton('postrm')
		btn_unpack = CheckButton('unpack')
		btn_compile = CheckButton('compile')
		btn_setup = CheckButton('setup')
		btn_test = CheckButton('test')
		btn_install = CheckButton('install')
		btn_other = CheckButton('other')

		self.attach(btn_preinst,  0, 1, 0, 1)
		self.attach(btn_postinst, 1, 2, 0, 1)
		self.attach(btn_prerm,    0, 1, 1, 2)
		self.attach(btn_postrm,   1, 2, 1, 2)
		self.attach(btn_unpack,   0, 1, 2, 3)
		self.attach(btn_compile,  1, 2, 2, 3)
		self.attach(btn_setup,    0, 1, 3, 4)
		self.attach(btn_test,     1, 2, 3, 4)
		self.attach(btn_install,  0, 1, 4, 5)
		self.attach(btn_other,    1, 2, 4, 5)

		# public
		self.btn_preinst = btn_preinst
		self.btn_postinst = btn_postinst
		self.btn_prerm = btn_prerm
		self.btn_postrm = btn_postrm
		self.btn_unpack = btn_unpack
		self.btn_compile = btn_compile
		self.btn_setup = btn_setup
		self.btn_test = btn_test
		self.btn_install = btn_install
		self.btn_other = btn_other

class ModelSelector(gtk.HBox):
	'''Two buttons for selecting the model'''

	def __init__(self):
		gtk.HBox.__init__(self)
		self.btn_liststore = gtk.RadioButton(None, 'List')
		self.btn_treeview  = gtk.RadioButton(self.btn_liststore, 'Tree view')
		self.add(self.btn_liststore)
		self.add(self.btn_treeview)


class TextBuffer(gtk.TextBuffer):

	def __init__(self):
		gtk.TextBuffer.__init__(self)
		self.create_tag('INFO', foreground='darkgreen')
		self.create_tag('WARN', foreground='red')
		self.create_tag('LOG', foreground='black')
		self.create_tag('ERROR', foreground='orange')


class Buffer(TextBuffer):
	header = None
	section = None
	line = None

	def __init__(self):
		TextBuffer.__init__(self)

	def get_filename(self, selection):
		# FIXME: not the best place
		[model, iter] = selection.get_selected()
		if not iter:
			# no selection
			return None
		filename = model.get_value(iter, FILENAME)
		if not filename:
			# selection of a tree branch
			return None
		if _debug:
			print filename
		return filename

	def clear(self):
		self.delete(
				self.get_start_iter(),
				self.get_end_iter())

	def insert_section(self):
		self.insert_with_tags(
				self.get_end_iter(),
				self.header + ' (' + self.section + ')\n\n',
				self.get_tag_table().lookup(self.header))

	def insert_body(self):
		self.insert_with_tags(
				self.get_end_iter(),
				self.line + '\n',
				self.get_tag_table().lookup(self.header))


	def read(self, selection):
		filename = self.get_filename(selection)
		if not filename:
			return

		file_obj = open(filename, 'r')
		self.clear()
		tags = self.get_tag_table()
		try:
			# Parse file
			for self.line in file_obj.read().splitlines():
				# section
				L = self.line.split(': ')
				if len(L) is 2 and (L[0] and L[1]) in filter.keys():
					(self.header, self.section) = L
					self.insert_section()
				else:
					if filter[self.header] and filter[self.section]:
						self.insert_body()
		finally:
			file_obj.close()


class TextView(gtk.TextView):

	def __init__(self):
		gtk.TextView.__init__(self)
		self.set_editable(False)
		self.set_cursor_visible(False)
		self.set_wrap_mode(gtk.WRAP_WORD)


class AboutDialog(gtk.AboutDialog):

	def __init__(self):
		gtk.AboutDialog.__init__(self)
		self.set_version( _version )
		self.set_website( _website )
		self.set_authors( _author )
		self.set_artists( _artists )
		self.set_copyright( _copyright )
		self.set_documenters( _documenter )
		self.set_license( _LICENSE )
		self.run()
		self.destroy()


class Info(gtk.MessageDialog):

	def __init__(self):
		gtk.MessageDialog.__init__(self, 
				parent=None, 
				flasgs=0, 
				type=gtk.MESSAGE_INFO, 
				buttons=gtk.BUTTONS_OK, 
				message_format=None)
		self.set_markup ( _description )
		self.run()
		self.destroy()


class ActionGroup(gtk.ActionGroup):

	def __init__(self, activate_action):
		gtk.ActionGroup.__init__(self, 'Main')

		entries = (
				( 'File', None, '_File' ),       # name, stock_id, label
				( 'Help', None, '_Help' ),
				( 'About', None, '_About...',
				),#	None, self.about()),
				( 'Info', None, 'Info',
				),#	None, self.info()),
				( 'Quit', gtk.STOCK_QUIT,        # name, stock_id
					'_Quit', '<control>Q',       # label, accelerator
					'Quit Elogviewer',           # tooltip
					activate_action ),
				( 'Delete', gtk.STOCK_DELETE,
					'_Delete', '<control>D',
					'Delete selected file',
					activate_action ),
				( 'Clear', gtk.STOCK_CLEAR,
					'_Clear', '<control>C',
					'Delete all the files',
					activate_action ),
				( 'Refresh', gtk.STOCK_REFRESH,
					'_Refresh', '<control>R',
					'Refresh the list',
					activate_action ),
				)
		self.add_actions(entries)

	def about(self, *args):
		AboutDialog()

	def info(self, *args):
		Info()


class UIManager(gtk.UIManager):

	def __init__ (self):

		gtk.UIManager.__init__ (self)
		self.add_ui_from_string('''
		<ui>
		<menubar name="Menubar">
			<menu action="File">
				<menuitem action="Delete" />
				<menuitem action="Clear"/>
				<menuitem action="Refresh"/>
				<separator/>
				<menuitem action="Quit"/>
			</menu>
			<menu action="Help">
				<menuitem action="Info"/>
					<menuitem action="About"/>
			</menu>
		</menubar>
		<toolbar name="Toolbar">
			<toolitem action="Delete"/>
			<toolitem action="Clear"/>
			<toolitem action="Refresh"/>
			<toolitem action="Quit"/>
		</toolbar>
		</ui>
		''')


# FIXME empty statusbar
class Statusbar(gtk.Statusbar):

	def __init__(self):
		gtk.Statusbar.__init__(self)


class Elogviewer(MainWindow):

	def __init__(self):
		# BEGIN GUI
		# Root window
		MainWindow.__init__(self)
		self.connect( 'destroy', lambda w: self.destroy() )

		# Box
		rootbox = gtk.VBox(False, 0)
		self.add(rootbox)
		
		ui = UIManager()
		ag = ActionGroup(self.action)
		ui.insert_action_group(ag, 0)

		menubar = ui.get_widget('/Menubar')
		toolbar = ui.get_widget('/Toolbar')
		accel_group = ui.get_accel_group()

		self.add_accel_group(accel_group)
		rootbox.pack_start(menubar, False)
		rootbox.pack_start(toolbar, False)

		vpaned = gtk.VPaned()
		rootbox.pack_start(vpaned)

		statusbar = Statusbar()
		rootbox.pack_start(statusbar, False)

		eloglist_box = ScrolledWindow()
		eloglist = TreeView()
		flat = ListStore()
		tree = TreeStore()
		eloglist_box.add(eloglist)
		vpaned.pack1(eloglist_box, True)

		elogview_box = ScrolledWindow()
		elogview = TextView()
		buffer = Buffer()
		elogview.set_buffer(buffer)
		elogview_box.add(elogview)

		botrightbox = gtk.VBox(False)
		f_header = HeaderTable()
		f_stage = StageTable()
		modelselector = ModelSelector()
		botrightbox.pack_start(f_header, False)
		botrightbox.pack_start(gtk.HSeparator(), False)
		botrightbox.pack_start(f_stage, False)
		botrightbox.pack_start(gtk.HSeparator(), False)
		botrightbox.pack_start(modelselector, False)

		botbox = gtk.HBox()
		botbox.pack_start(elogview_box)
		botbox.pack_start(botrightbox, False)
		vpaned.pack2(botbox, True)

		self.show_all()
		# END GUI

		# connections
		eloglist.get_selection().connect_object(
				'changed', elogview.get_buffer().read, \
						eloglist.get_selection())
		modelselector.btn_treeview.connect('toggled', self.set_model)
		# connect the filter
		f_header.btn_info.connect('toggled', self.filter)
		f_header.btn_warn.connect('toggled', self.filter)
		f_header.btn_error.connect('toggled', self.filter)
		f_header.btn_log.connect('toggled', self.filter)
		
		f_stage.btn_preinst.connect('toggled', self.filter)
		f_stage.btn_postinst.connect('toggled', self.filter)
		f_stage.btn_prerm.connect('toggled', self.filter)
		f_stage.btn_postrm.connect('toggled', self.filter)
		f_stage.btn_unpack.connect('toggled', self.filter)
		f_stage.btn_compile.connect('toggled', self.filter)
		f_stage.btn_setup.connect('toggled', self.filter)
		f_stage.btn_test.connect('toggled', self.filter)
		f_stage.btn_install.connect('toggled', self.filter)
		f_stage.btn_other.connect('toggled', self.filter)

		# public
		self.eloglist = eloglist
		self.tree = tree
		self.flat = flat
		self.buffer = buffer
		self.elogview = elogview

		# default model flat or tree
		self.set_model(modelselector.btn_treeview)

	def destroy(self):
		gtk.main_quit()

	def set_model(self, is_treeview):
		if is_treeview.get_active():
			self.eloglist.set_model(self.tree)
		else:
			self.eloglist.set_model(self.flat)
		self.eloglist.get_model().populate()
	
	def filter(self, chk_btn):
		filter[chk_btn.get_label()] = chk_btn.get_active()
		# update
		self.buffer.read(self.eloglist.get_filenam())

	def delete(self):
		selection = self.eloglist.get_selection()
		self.eloglist.get_model().delete(selection)

	def clear(self):
		selection = self.eloglist.get_selection()
		[model, iter] = selection.get_selected()
		while iter:
			self.delete()
			[model, iter] = selection.get_selected()
	
	def action(self, action_obj):
		action = action_obj.get_name()
		print "action %s" % action
		if action == "Delete":
			self.delete()
		if action == "Clear":
			self.clear()
		if action == "Refresh":
			self.eloglist.get_model().populate()
		if action == "Quit":
			self.destroy()


def main():
	gtk.main()
	return 0


if __name__ == "__main__":
	Elogviewer()
	main()

# Refs
# http://www.javaworld.com/jw-07-1999/jw-07-toolbox.html
# http://www.pygtk.org/pygtk2reference/
# http://docs.python.org/
# Python Cookbook, 2nd ed., O'Reilly
# http://www.mono-project.com/GtkSharp_TreeView_Tutorial
# http://www.pygtk.org/pygtk2tutorial/sec-TreeModelInterface.html

# EOF
