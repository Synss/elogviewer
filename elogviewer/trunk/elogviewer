#!/usr/bin/env python

_debug         = True

__author__     = 'Mathias Laurin <mathias_laurin@users.sourceforge.net>'
__documenter__ = 'Christian Faulhammer <opfer@gentoo.org>'
__artists__    = 'elogviewer needs a logo, \nartists are welcome to contribute, \nplease contact the author.\n' + __author__
__appname__    = 'elogviewer'
__version__    = '0.5.1'
__website__    = 'http://sourceforge.net/projects/elogviewer'
__copyright__  = 'Copyright (c) 2006 ' + __author__
__license__    = 'GNU General Public License (GPL) version 2'


__LICENSE__    = __copyright__ + '''

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.'''


__description__ = '''
elogviewer lists all elogs created during emerges of packages from Portage, 
the package manager of Gentoo Linux.  So all warnings or informational 
messages generated during an update can be reviewed at one glance.

man 1 elogviewer and man 1 /etc/make.conf for more informations.

Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.
Jeremy Wickersheimer adapted elogviewer to KDE, some features he added were
back ported in elogviewer.
Christian Faulhammer (V-Li) has written the man page.
'''


try:
	import pygtk
	pygtk.require('2.0')
except:
	print "Please run: emerge --sync && emerge pygtk"

import gtk
from   gobject  import TYPE_STRING, TYPE_PYOBJECT
import portage
import os
import time
import re

### Redirect any message from sdtout to stderr
from sys     import stdout, stderr
stdout = stderr

if _debug:
	print 'Running debug mode'
	os.chdir("elog")
else:
	try:
		os.chdir(portage.settings["PORT_LOGDIR"])
	except:
		os.chdir("/var/log/portage")
	try:
		os.chdir("./elog")
	except:
		print '''
Please install the elog feature as explained in the ebuild and
in /etc/make.conf.example
you should have at least one of 
	PORTAGE_ELOG_CLASSES="info warn error log"
and
	PORTAGE_ELOG_SYSTEM="save"
in your /etc/make.conf
		'''


class ScrolledWindow (gtk.ScrolledWindow):

	def __init__ (self, child):
		gtk.ScrolledWindow.__init__ (self)
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		self.add (child)

(
	CATEGORY_COLUMN,
	PACKAGE_COLUMN,
	TIMESTAMP_COLUMN,
	FILENAME_COLUMN
) = range(4)


class ListStore (gtk.ListStore):

		### DEBUG ListStore, GenericTreeModel, ...
		def __init__ (self):
			self = gtk.ListStore.__init__ (self, TYPE_STRING, TYPE_STRING, TYPE_STRING,\
							TYPE_PYOBJECT)
			#gtk.ListStore.__init__ (self, TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_PYOBJECT) 

		def populate (self):
			for filename in os.listdir(os.getcwd()):
				log = self.__split_colon(filename)
				self.append(log)

		def __split_colon (self, filename):
			intimeformat  = '%Y%m%d-%H%M%S.log'
			outtimeformat = '%Y-%m-%d %H:%M:%S'

			(c, p, t) = re.split(':', str(filename))
			t = time.strptime (t, intimeformat)
			t = time.strftime (outtimeformat, t)

			return [c, p, t, filename]
		

class FileList (gtk.TreeView):

		def __init__ (self, selection_handler):

			col_headers = ['Category', 'Package', 'Timestamp']
			model       = ListStore()
			gtk.TreeView.__init__ (self, model)
			self.set_enable_search(True)
			self.set_search_column(PACKAGE_COLUMN)	
			#self.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

			for c in range(len(col_headers)):
				cell = gtk.CellRendererText()
				col  = gtk.TreeViewColumn(col_headers[c], cell, text=c)
				col.set_sort_column_id(c)
				self.append_column(col)

			# Selection handler
			self.get_selection().connect_object('changed', selection_handler, None)

			# Export
			self.populate = model.populate


class Buffer (gtk.TextBuffer):
		
		def __init__ (self):
			gtk.TextBuffer.__init__ (self)
			self.set_text('No selection')
			tag = self.create_tag('INFO', foreground='darkgreen')
			tag = self.create_tag('WARN', foreground='red')
			tag = self.create_tag('LOG',  foreground='black')
			tag = self.create_tag('ERROR',foreground='orange')


class LogView (gtk.TextView):

		def __init__ (self):
			gtk.TextView.__init__ (self)
			self.set_editable (False)
			self.set_cursor_visible (False)
			self.set_wrap_mode (gtk.WRAP_WORD)

			self.buffer = Buffer()
			self.set_buffer (self.buffer)

		def __strip_nl (self, line):
			return re.match(r'^([^\\\n]*)', line).group(1)

		def set_text (self, filename):
			### local header list
			header_labels = ''
			for h in Filter.header.keys():
				if header_labels == '':
					header_labels = h
				else:
					header_labels = header_labels + '|' + h
			header_labels = re.compile(header_labels)

			### Read the file
			file      = open(filename, 'r')
			readline  = ''
			firstline = True
			for readline in file:
				readline = self.__strip_nl(readline)

				### is section?
				if header_labels.match(readline):
					line = readline.split(': ')
					h = line[0]
					s = line[1]
					if firstline:
						self.buffer.set_text('')
						firstline = False
					else:
						self.buffer.insert_at_cursor ('\n')
					
					line = '%s (%s)\n' % (h, s)
					iter = self.buffer.get_end_iter()
					self.buffer.insert_with_tags_by_name(iter, line, h)

				### content?
				elif Filter.header[h] and Filter.stage[s]:
					line = '%s\n' % readline
					iter = self.buffer.get_end_iter()
					self.buffer.insert_with_tags_by_name(iter, line, h)
					#self.buffer.insert_at_cursor (line)


class Filter(gtk.VBox):

		header = {'INFO': bool(), 'WARN': bool(), 'ERROR': bool(), 'LOG': bool()}
		stage  = {'preinst': bool(), 'postinst': bool(), 'postrm': bool(), 'prerm': bool(), \
					'unpack': bool(), 'compile': bool(), 'setup': bool(), 'test': bool(), \
					'install': bool(), 'other': bool()}
	
		def __init__ (self, selection_changed):
			gtk.VBox.__init__ (self)
			separator = gtk.HSeparator()

			headerbox = self.get_box(self.header)
			self.pack_start (headerbox, False)
			self.pack_start (separator, False)
			stagebox  = self.get_box(self.stage)
			self.pack_start (stagebox, False)
			
			self.selection_changed = selection_changed

		### NOTE: won't work on odd number of stage/header
		### fix it if ever it happens someday:
		### a dummy box that is not shown would do
		def get_box(self, dict):
			box = gtk.Table(len(dict)/2, 2, True)
			btn = {}
			row = 0
			col = 0
			for label in dict.keys():
				btn[label]   = gtk.CheckButton( label, False )
				btn[label].set_active(True)
				dict[label]  = True
				btn[label].connect('toggled', self.toggle, dict, label)
				box.attach(btn[label], col, col+1, row, row+1)
				col += 1
				if col == 2:
					col  = 0
					row += 1
			#self.emit('changed')
			return box

		def toggle(self, btn, dict, label):
			dict[label] = not dict[label]
			self.selection_changed()


class Actions(gtk.UIManager):

		def __init__ (self, delete, clear, refresh, quit):
			gtk.UIManager.__init__ (self)

			ui = '''<ui>
			<menubar name="Menubar">
				<menu action="File">
					<menuitem action="Delete"/>
					<menuitem action="Clear"/>
					<menuitem action="Refresh"/>
					<separator/>
					<menuitem action="Quit"/>
				</menu>
				<menu action="Help">
					<menuitem action="Info"/>
					<menuitem action="About"/>
				</menu>
			</menubar>
			<toolbar name="Toolbar">
				<toolitem action="Quit"/>
				<toolitem action="Delete"/>
				<toolitem action="Clear"/>
				<toolitem action="Refresh"/>
			</toolbar>
			</ui>'''

			action_group = gtk.ActionGroup('Main')
			action_group.add_actions([
			('File',    None, '_File'),
			('Help',    None, '_Help'),
			('About',   None, '_About...', None, None, self.about_box),
			('Info',    None, '_Info',     None, None, self.info_box),
			('Quit',    gtk.STOCK_QUIT,   '_Quit',   'q', 'Quit', quit),
			('Delete',  gtk.STOCK_DELETE, '_Delete', 'd', 'Delete selected entry', delete),
			('Clear',   gtk.STOCK_CLEAR,  '_Clear',  'c', 'Clear all', clear),
			('Refresh', gtk.STOCK_REFRESH,'_Refresh','r', 'Refresh', refresh)
			])
			
			self.insert_action_group(action_group, 0)
			self.add_ui_from_string(ui)

			### Extract widgets
			self.menubar     = self.get_widget('/Menubar')
			self.toolbar     = self.get_widget('/Toolbar')
			self.accel_group = self.get_accel_group()

		def about_box (self, *args):
			d = gtk.AboutDialog()
			d.set_version( __version__ )
			d.set_website( __website__ )
			d.set_authors( [__author__, 'Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.'] )
			d.set_artists( [__artists__] )
			d.set_copyright( __copyright__ )
			d.set_documenters( [__documenter__, __author__] )
			d.set_license( __LICENSE__ )
			d.run()
			d.destroy()

		def info_box (self, *args):
			d = gtk.MessageDialog(None, 0, gtk.MESSAGE_INFO, gtk.BUTTONS_OK, None)
			d.set_markup ( __description__ )
			d.run()
			d.destroy()


class Statusbar (gtk.Statusbar):

		def __init__ (self):
			gtk.Statusbar.__init__(self)

		def update(self, text):
			self.push(0, text)


class Elogviewer (gtk.Window):
		
		def destroy (self, *args):
			gtk.main_quit()
	
		def __init__ (self):
			### Initialize main window
			gtk.Window.__init__ (self, gtk.WINDOW_TOPLEVEL)
			self.set_title( __appname__ )
			self.connect( "destroy", lambda w: self.destroy() )
			self.set_default_size( 800, 600 )
			self.show()

			### Initialize widgets
			actions  = Actions(self.delete, self.clear, self.refresh, self.destroy)
			filter   = Filter(self.selection_changed)
			pane     = gtk.VPaned()
			filelist = FileList(self.selection_changed)
			logview  = LogView()
			statusbar= Statusbar()

			### Accelerators
			self.add_accel_group(actions.accel_group)

			### Box for packing widgets
			rootbox  = gtk.VBox (False, 0)
			self.add(rootbox)
			self.rootbox = rootbox

			rootbox.pack_start(actions.menubar, False)
			rootbox.pack_start(actions.toolbar, False)
			rootbox.pack_start(pane)
			rootbox.pack_start(statusbar, False)
			rootbox.show()

			### Fill main window (double pane)
			scfilelist = ScrolledWindow(filelist)
			pane.pack1  (scfilelist, True)
			###
			_botbox    = gtk.HBox()
			sclogview  = ScrolledWindow(logview)
			_botbox.pack_start(sclogview, True)
			_botbox.pack_start(filter, False)
			pane.pack2  (_botbox, True)
			###
			pane.show_all()

			### Show status bar
			statusbar.show()

			### Export
			self.filelist  = filelist
			self.selection = filelist.get_selection()
			self.logview   = logview
			self.statusbar = statusbar

			### Populate!
			filelist.populate()
			if not _debug:
				self.selection.select_path(0)

		### Actions
		def selection_changed (self, *args):
			[model, iter] = self.selection.get_selected()
			if iter is None:
				# No selection
				self.logview.buffer.set_text('No elogs left, thank you for using elogviewer.')
			else:
				filename = model.get_value(iter, FILENAME_COLUMN)
				self.logview.set_text(filename)
				# Collect other infos for the statusbar
				tot_files = model.iter_n_children(None)
				sel_file  = model.get_path(iter)[0] + 1
				statusbartext = str(sel_file) + '/' + str(tot_files) + ' file: ' + filename
				self.statusbar.update(statusbartext)

		def delete (self, *args):
			[model, iter]  = self.selection.get_selected()
			if iter is None:
				# No selection
				return 

			filename = model.get_value(iter, FILENAME_COLUMN)
			path     = model.get_path(iter)

			model.remove (iter)
			if _debug:
				print filename
			else:
				os.remove (filename)

			if model.iter_is_valid(iter):
				self.selection.select_iter(iter)
			else:
				# Last in the list?
				# select last but one but not if list is empty
				newpath = (path[0]-1,)
				if newpath != (-1,):
					self.selection.select_path(newpath)

		def clear (self, *args):
			button = gtk.BUTTONS_YES_NO
			dialog = gtk.MessageDialog(None, 0, gtk.MESSAGE_WARNING, button, \
				"The whole elog directory is going to be wiped out.\nAre you sure you want to proceed?")
			clear = dialog.run()
			dialog.destroy()

			if clear == gtk.RESPONSE_YES:
				self.selection.select_path(0)
				while self.selection.path_is_selected(0):
					self.delete()


		def refresh(self, *args):
			self.filelist.populate()


def main():
		gtk.main()
		return 0


if __name__ == "__main__":
		Elogviewer()
		main()

### Refs
# http://www.javaworld.com/jw-07-1999/jw-07-toolbox.html
