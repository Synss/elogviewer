#!/usr/bin/env python

__author__     = 'Mathias Laurin <mathias_laurin@users.sourceforge.net>'
__documenter__ = 'Christian Faulhammer <gentoo@faulhammer.org>'
__artists__    = 'elogviewer needs a logo, \nartists are welcome to contribute, \nplease contact the author.\n' + __author__
__appname__    = 'elogviewer'
__version__    = '0.5.0'
__website__    = 'http://sourceforge.net/projects/elogviewer'
__copyright__  = 'Copyright (c) 2006 ' + __author__
__license__    = 'GNU General Public License (GPL) version 2'


__LICENSE__    = __copyright__ + '''

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.'''


__description__ = '''elogviewer lists all elogs created during emerges of
packages from Portage, the package manager of Gentoo Linux.  So all
warnings or informational messages generated during an update can be
reviewed at one glance.

man 1 elogviewer and man 1 /etc/make.conf for more informations.

Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.
Christian Faulhammer (V-Li) has written the man page.'''


try:
	import pygtk
	pygtk.require ( '2.0' )
except:
	print "Please run: emerge --sync && emerge pygtk"

import gtk, gobject
import sys, os, portage
import time, re

### Redirect any message from sdtout to stderr
sys.stdout = sys.stderr

# DEBUG #
#os.chdir( "elog" )
try:
	os.chdir( portage.settings["PORT_LOGDIR"] )
except:
	os.chdir( "/var/log/portage" )
try:
	os.chdir( "./elog" )
except:
	print '''
Please install the elog feature as explained in the ebuild and
in /etc/make.conf.example
you should have at least one of 
	PORTAGE_ELOG_CLASSES="info warn error log"
and
	PORTAGE_ELOG_SYSTEM="save"
in your /etc/make.conf
	'''

class ScrolledWindow(gtk.ScrolledWindow):
	def __init__(self):
		gtk.ScrolledWindow.__init__(self)
		self.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )

class InitGUI (gtk.Window):
	def __init__ (self):
		gtk.Window.__init__ (self, gtk.WINDOW_TOPLEVEL)
		self.set_title( __appname__ )
		self.connect( "destroy", lambda w: gtk.main_quit() )
		self.set_default_size( 800, 600 )

		rootbox = gtk.VBox( False, 0 )
		self.add(rootbox)

		pane = gtk.VPaned()
		rootbox.pack_end(pane)

		_topbox = gtk.HBox()
		_botbox = gtk.HBox()
		pane.pack1(_topbox, True)
		pane.pack2(_botbox)

		topbox    = ScrolledWindow()
		botbox    = ScrolledWindow()
		filterbox = gtk.HBox()

		_topbox.add(topbox)
		_botbox.pack_start(botbox, True)
		_botbox.pack_start(filterbox, False)

		self.rootbox   = rootbox
		self.topbox    = topbox
		self.botbox    = botbox
		self.filterbox = filterbox

class FileList (gtk.TreeView):

		def __init__ (self, parent):

			col_headers = [ "Category", "Package", "Timestamp" ]
			model = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_STRING, gobject.TYPE_STRING, gobject.TYPE_PYOBJECT)
			gtk.TreeView.__init__ (self, model)

			parent.add (self)
			self.model = model
			#self.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

			for c in range( len(col_headers) ):
				cell = gtk.CellRendererText()
				col  = gtk.TreeViewColumn(col_headers[c], cell, text=c)
				col.set_sort_column_id( c )
				self.append_column(col)

		def populate (self):
			for filename in os.listdir( os.getcwd() ):
				log = self.split_colon(filename)
				self.model.append( log )

		def split_colon (self, filename):
			intimeformat  = "%Y%m%d-%H%M%S.log"
			outtimeformat = "%Y-%m-%d %H:%M:%S"

			(c, p, t) = re.split( ":", str(filename) )
			t = time.strptime( t, intimeformat  )
			t = time.strftime( outtimeformat, t )

			return [c, p, t, filename]

class LogView (gtk.TextView):
		def __init__ (self, parent):
			gtk.TextView.__init__ (self)
			self.set_editable (False)
			self.set_cursor_visible (False)
			self.set_wrap_mode (gtk.WRAP_WORD)
			parent.add (self)

		def strip_nl(self, line):
			return re.match( r'^([^\\\n]*)', line ).group( 1 )

		def set_text (self, filename=None):
			### Init buffer
			buffer        = self.get_buffer()
			buffer.set_text ('')

			### local header list
			header_labels = ''
			for h in Filter.header.keys():
				if header_labels == '':
					header_labels = h
				else:
					header_labels = header_labels + '|' + h
			header_labels = re.compile( header_labels )

			### Read the file
			file      = open( filename, 'r' )
			readline  = ''
			firstline = True
			for readline in file:
				readline = self.strip_nl (readline)

				### is section?
				if header_labels.match (readline):
					line = readline.split( ': ' )
					h    = line[0]
					s    = line[1]
					if firstline:
						firstline = False
					else:
						buffer.insert_at_cursor ('\n')

					buffer.insert_at_cursor ('%s (%s)\n' % (h, s))

				### filter section content?
				elif Filter.header[h] and Filter.stage[s]:
					buffer.insert_at_cursor ( '%s\n' % readline)

class Filter(gtk.VBox):

		header = { "INFO": bool(), "WARN": bool(), "ERROR": bool(), "LOG": bool() }
		stage  = { "preinst": bool(), "postinst": bool(), \
					"postrm": bool(), "prerm": bool(), \
					"unpack": bool(), \
					"compile": bool(), "setup": bool(), "test": bool(), "install": bool(), \
					"other": bool()}
	
		def __init__ (self, parent):
			gtk.VBox.__init__ (self)
			separator = gtk.HSeparator()

			headerbox = self.get_box(self.header)
			self.pack_start (headerbox, False)
			self.pack_start (separator, False)
			stagebox  = self.get_box(self.stage)
			self.pack_start (stagebox, False)

			parent.add (self)

		### NOTE: won't work on odd number of stage/header
		### fix it if ever it happens someday...
		def get_box(self, dict):
			box = gtk.Table(len(dict)/2, 2, True)
			btn = {}
			row = 0
			col = 0
			for label in dict.keys():
				btn[label]   = gtk.CheckButton( label, False )
				btn[label].set_active(True)
				dict[label]  = True
				btn[label].connect( "toggled", self.toggle, dict, label )
				box.attach(btn[label], col, col+1, row, row+1)
				col += 1
				if col == 2:
					col  = 0
					row += 1
			return box

		def toggle(self, btn, dict, label):
			dict[label] = not dict[label]
			
class Actions(gtk.UIManager):

		def __init__ (self, parent, delete_action, clear_action, refresh_action):
			gtk.UIManager.__init__ (self)

			ui = '''<ui>
			<menubar name="Menubar">
				<menu action="File">
					<menuitem action="Delete"/>
					<menuitem action="Clear"/>
					<menuitem action="Refresh"/>
					<separator/>
					<menuitem action="Quit"/>
				</menu>
				<menu action="Help">
					<menuitem action="Info"/>
					<menuitem action="About"/>
				</menu>
			</menubar>
			<toolbar name="Toolbar">
				<toolitem action="Quit"/>
				<toolitem action="Delete"/>
				<toolitem action="Clear"/>
				<toolitem action="Refresh"/>
			</toolbar>
			</ui>'''

			### Actually build the UI
			action_group = gtk.ActionGroup('Main')
			action_group.add_actions([
			('File',    None, '_File'),
			('Help',    None, '_Help'),
			('About',   None, '_About...',          None, None,          self.about_box     ),
			('Info',    None, '_Info',              None, None,          self.info_box      ),
			('Quit',    gtk.STOCK_QUIT,   '_Quit',   'q', 'Quit',        gtk.main_quit      ),
			('Delete',  gtk.STOCK_DELETE, '_Delete', 'd', 'Delete selected entry', delete_action ),
			('Clear',   gtk.STOCK_CLEAR,  '_Clear',  'c', 'Clear all',   clear_action ),
			('Refresh', gtk.STOCK_REFRESH,'_Refresh','r', 'Refresh',     refresh_action  )])
			
			self.insert_action_group(action_group, 0)
			self.add_ui_from_string(ui)

			### extract widgets
			menubar     = self.get_widget('/Menubar')
			toolbar     = self.get_widget('/Toolbar')
			accel_group = self.get_accel_group()

			parent.rootbox.pack_start(menubar, False)
			parent.rootbox.pack_start(toolbar, False)
			parent.add_accel_group(accel_group)

		def about_box (self, *args):
			d = gtk.AboutDialog()
			d.set_version( __version__ )
			d.set_website( __website__ )
			d.set_authors( [__author__, 'Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.'] )
			d.set_artists( [__artists__] )
			d.set_copyright( __copyright__ )
			d.set_documenters( [__documenter__, __author__] )
			d.set_license( __LICENSE__ )
			d.run()
			d.destroy()

		def info_box (self, *args):
			d = gtk.MessageDialog(None, 0, gtk.MESSAGE_INFO, gtk.BUTTONS_OK, None)
			d.set_markup ( __description__ )
			d.run()
			d.destroy()

class Elogviewer:
	
		def __init__ (self):

			### Initialize widgets
			GUI      = InitGUI()
			actions  = Actions(GUI, self.delete, self.clear, self.refresh)
			filelist = FileList( GUI.topbox )
			filter   = Filter  ( GUI.filterbox )
			logview  = LogView ( GUI.botbox )

			filelist.populate()

			### Handle selection
			filelist.get_selection().connect_object('changed', self.selection_change, None)
			
			### Define self
			self.filelist  = filelist
			self.selection = filelist.get_selection()
			self.logview   = logview

			### WARNING: DO NOT REMOVE, YOU STUPID!
			GUI.show_all()
			### END OF WARNING

		### Actions
		def selection_change(self, *args):
			try:
				[model,iter] = self.selection.get_selected()
				filename     = model.get_value(iter,3)
				self.logview.set_text(filename)
			except:
				pass

		def delete(self, *args):
			### That one is a bit ugly...
			try:
				[model,iter]    = self.selection.get_selected()
				path            = model.get_path(iter)
				filename        = model.get_value(iter,3)

				model.remove (iter)
				os.remove  (filename)
				#print filename

				if model.iter_is_valid(iter):
					self.selection.select_iter(iter)
				else:
					# Last position in the list, 
					# select last but one
					newpath = (path[0]-1,)
					# but not if list is empty
					if newpath != (-1,): 
						self.selection.select_path(newpath)
			except:
				# No selection
				return False

		def clear(self, *args):
			button = gtk.BUTTONS_YES_NO
			dialog = gtk.MessageDialog(None, 0, gtk.MESSAGE_WARNING, button, \
				"The whole elog directory is going to be wiped out.\nAre you sure you want to proceed?")
			clear = dialog.run()
			dialog.destroy()

			if clear == gtk.RESPONSE_YES:
				self.selection.select_path(0)
				while self.selection.path_is_selected(0):
					self.delete()


		def refresh(self, *args):
			self.filelist.populate()


def main():
		gtk.main()
		return 0

if __name__ == "__main__":
		Elogviewer()
		main()

### Refs
# http://www.javaworld.com/jw-07-1999/jw-07-toolbox.html
