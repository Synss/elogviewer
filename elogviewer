#!/usr/bin/env python

try:
	import pygtk
except:
	print """
	Elogviewer requires pygtk and portage 2.1.

	emerge pygtk
	"""
try:
	pygtk.require( '2.0' )
except:
	print """
	Elogviewer requires pygtk and portage 2.1.

You are using an obsolete version of pygtk, please update to run Elogviewer.

	emerge pygtk
	"""
import gtk, gobject#, pango
import sys, os, portage
import time, re


try:
	os.chdir( portage.settings["PORT_LOGDIR"] )
except:
	os.chdir( "/var/log/portage" )
try:
	os.chdir( "./elog" )
except:
	print """
	Elogviewer requires portage 2.1.
	
	It seems you do not have the elog facility on your system:
If you are already using portage 2.1, you need to edit your /etc/make.conf and add at least:

	PORTAGE_ELOG_CLASSES="info warn error log"
	PORTAGE_ELOG_SYSTEM="save"

Please refer to /etc/make.conf.example for more info.

Voir /etc/make.conf.example pour plus d'options.
"""

# Print command is used for errors, redirect to stderr
sys.stdout = sys.stderr

class Logentry:
	
	def __init__(self, filename):
		intimeformat  = "%Y%m%d-%H%M%S.log"
		outtimeformat = "%Y-%m-%d %H:%M:%S"

		(c, p, t) = re.split( ":", str(filename) )
		self.category  = c
		self.package   = p
		t = time.strptime( t, intimeformat  )
		t = time.strftime( outtimeformat, t )
		self.timestamp = t
		self.filename  = filename

class Displaylog:
	
	textview = gtk.TextView()

	def make_window(self):
		self.window = gtk.ScrolledWindow()
		self.window.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )

		self.textview.set_editable(False)
		self.textview.set_cursor_visible(False)
		self.textview.set_wrap_mode(gtk.WRAP_WORD)
		
		self.window.add( self.textview )
		return self.window
	
	def strip_nl(self, line):
		return re.match( r'^([^\\\n]*)', line ).group( 1 )

	def parselog(self, filename):
		headerpattern = re.compile('^(INFO|WARN|ERROR|LOG)' )
		buffer        = self.textview.get_buffer()
		buffer.set_text("")
		firstline     = True
		i             = buffer.get_start_iter()
		file          = open( filename, 'r' )
		for readline in file:
			readline = self.strip_nl(readline)
			if headerpattern.match(readline):
				l = readline.split( ": " )
				header = l[0]
				stage  = l[1]
				if firstline:
					firstline = False
				else:
					buffer.insert(i, "\n")
				buffer.insert(i, "%s (%s)\n" % (header, stage) )
			elif Filter.filter[header] and Filter.filter[stage]:
				if readline is not "":
					buffer.insert(i, "%s\n" % readline)

class Filelist:

	liststore = gtk.ListStore( gobject.TYPE_STRING, gobject.TYPE_STRING, gobject.TYPE_STRING, \
			gobject.TYPE_PYOBJECT )
	treeview  = gtk.TreeView( liststore )

	def make_window(self):
		self.window = gtk.ScrolledWindow()
		self.window.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )
		self.window.add( self.treeview )

		col_headers = [ "Category", "Package", "Timestamp" ]
		for c in range( len(col_headers) ):
			cell = gtk.CellRendererText()
			col  = gtk.TreeViewColumn(col_headers[c], cell, text=c)
			col.set_sort_column_id( c )
			self.treeview.append_column(col)

		selection = self.treeview.get_selection()
		selection.set_mode( gtk.SELECTION_SINGLE )
		selection.connect_object( "changed", self.selectionchange_event, None)

		return self.window


	def get_selected(self):
		(m, i)    = self.treeview.get_selection().get_selected()
		selected  = m.get_value( i, 3 )
		return selected, i

	def selectionchange_event(self, foo=None):
		if self.treeview.get_selection().count_selected_rows() is not 0:
			(selected, iter)  = self.get_selected()
			Displaylog.parselog(self, selected)
	
	def populate(self):
		for f in os.listdir( os.getcwd() ):
			try:
				log = Logentry(f)
				self.liststore.append( [log.category, log.package, log.timestamp, log.filename] )
			except:
				print f
		self.liststore.set_sort_column_id(2, gtk.SORT_DESCENDING )
		self.treeview.get_selection().select_path(0)
		
class Actions(Filelist):

	ui = '''<ui>
	<menubar name="Menubar">
		<menu action="File">
			<menuitem action="Delete"/>
			<menuitem action="Clear"/>
			<menuitem action="Refresh"/>
			<separator/>
			<menuitem action="Quit"/>
		</menu>
		<menu action="Help">
			<menuitem action="About"/>
		</menu>
	</menubar>
	<toolbar name="Toolbar">
		<toolitem action="Quit"/>
		<toolitem action="Delete"/>
		<toolitem action="Clear"/>
		<toolitem action="Refresh"/>
	</toolbar>
	</ui>'''

	about = '''elogviewer parses the elogs in a gtk (graphical) environment. \
elogs are a new feature in portage 2.1 and above that stores informational messages contained \
in the ebuilds and displayed during the merges for later and easier reading.\n
See man elogviewer and your /etc/make.conf.example for turning that feature on.\n\n
From left to right, clicking the button will:
\tExit Elogviewer
\tDelete current entry
\tClear all entries
\tRefresh list\n
elogviewer v. 0.4.1\n
(c) 2006, Mathias Laurin (synss),\n http://sourceforge.net/projects/elogviewer/\n
elogviewer was born from an idea of Timothy Kilbourn (nmbrthry).\n
Thank you to Christian Faulhammer (V-Li) for taking care of the man page.\n\n
Distributed under the GPL version 2 and above.'''

	def about_event(self, widget, event=None):
		dialog = gtk.MessageDialog(None, 0, gtk.MESSAGE_INFO, gtk.BUTTONS_OK, None)
		dialog.set_markup( self.about )
		dialog.run()
		dialog.destroy()

	def clear_event(self, widget, event=None):
		button = gtk.BUTTONS_YES_NO
		dialog = gtk.MessageDialog(None, 0, gtk.MESSAGE_WARNING, button, \
				"The whole elog directory is going to be wiped out.\n\
				Are you sure you want to proceed?")
		clear = dialog.run()
		dialog.destroy()
		
		if clear == gtk.RESPONSE_YES:
			Filelist.treeview.get_selection().select_path(0)
			while self.treeview.get_selection().count_selected_rows() is not 0:
				self.delete_event(self, widget)

	def delete_event(self, widget, event=None):
		(filename, iter) = Filelist.get_selected(self)
		Filelist.liststore.remove(iter)
		#DEBUG
		os.remove( filename )
		#print filename, iter
		if Filelist.liststore.iter_is_valid(iter):
			Filelist.treeview.get_selection().select_iter( iter )
		else:
			#DEBUG: Is there a more elegant way of selecting the last entry?
			i = 0
			Filelist.treeview.get_selection().select_path( i )
			while Filelist.treeview.get_selection().path_is_selected( i ):
				i = i + 1
				Filelist.treeview.get_selection().select_path( i )
			Filelist.treeview.get_selection().select_path( i-1 )

	def quit_event(self, widget, event=None):
		gtk.main_quit()
		return 0

	def refresh_event(self, widget, event=None):
		Filelist.liststore.clear()
		Filelist.populate(self)

	def make_actions(self):
		uimanager   = gtk.UIManager()
		actiongroup = gtk.ActionGroup('Main')
		actiongroup.add_actions([
			('File', None, '_File'),
			('Help', None, '_Help'),
			('About', None, '_About...', None, None, self.about_event),
			('Quit', gtk.STOCK_QUIT, '_Quit', 'q', 'Quit', self.quit_event),
			('Delete', gtk.STOCK_DELETE, '_Delete', 'd', 'Delete selected entry', self.delete_event),
			('Clear', gtk.STOCK_CLEAR, '_Clear', 'c', 'Clear all', self.clear_event),
			('Refresh', gtk.STOCK_REFRESH, '_Refresh', 'r', 'Refresh', self.refresh_event)])
		uimanager.insert_action_group(actiongroup, 0)
		uimanager.add_ui_from_string(self.ui)
		return uimanager

class Filter:
	
	filter = { "INFO": bool(), "WARN": bool(), "ERROR": bool(), "LOG": bool(), \
		"preinst": bool(), "unpack": bool(), "setup": bool(), \
		"compile": bool(), "install": bool(), "postinst": bool(), \
		"postrm": bool(), "prerm": bool(), \
		"test": bool(), \
		"other": bool()}
	
	def toggle(self, widget, data):
		self.filter[data]= not self.filter[data]
		try:
			filename, i = Filelist.get_selected(self)
			Displaylog.parselog(self, filename)
		except:
			pass

	def make_window(self):
		window = gtk.HandleBox()
		box = gtk.Table(len(self.filter), 1, True)
		showprefsbtn = {}
		row = 0
		for label in self.filter.keys():
			showprefsbtn[label] = gtk.CheckButton( label, False )
			showprefsbtn[label].set_active(True)
			self.filter[label]   = True
			showprefsbtn[label].connect( "toggled", self.toggle, label )
			box.attach(showprefsbtn[label], 0, 1, row, row+1)
			row += 1
		window.add(box)
		return window


class Mainwindow(Displaylog, Actions, Filter):

	def __init__(self):
		filelist   = Filelist.make_window(self)
		displaylog = Displaylog.make_window(self)
		filter     = Filter.make_window(self)

		bottombox = gtk.HBox()
		bottombox.pack_start(displaylog, gtk.FILL)
		bottombox.pack_end(filter, False)

		vpaned = gtk.VPaned()
		vpaned.add1( filelist )
		vpaned.add2( bottombox )
		vpaned.set_position( 250 )

		rootbox = gtk.VBox(False, 0)
		uimanager = Actions.make_actions(self)
		menubar = uimanager.get_widget('/Menubar')
		rootbox.pack_start(menubar, False)
		toolbar = uimanager.get_widget('/Toolbar')
		rootbox.pack_start(toolbar, False)
		rootbox.pack_start(vpaned,  True,  True,  0)

		accelgroup  = uimanager.get_accel_group()

		window = gtk.Window( gtk.WINDOW_TOPLEVEL )
		window.set_title( "elog viewer" )
		window.connect( "destroy", lambda w: gtk.main_quit() )
		window.set_size_request( 850, 600 )
		window.add(rootbox)
		window.add_accel_group(accelgroup)

		window.show_all()

class Elogviewer(Mainwindow):
	
	def __init__(self):
		Mainwindow()
		Filelist.populate(self)

def main():
	gtk.main()
	return 0

if __name__ == "__main__":
	Elogviewer()
	main()
