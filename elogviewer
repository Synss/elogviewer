#!/usr/bin/env python
_debug = True

_author     = ['Mathias Laurin <mathias_laurin@users.sourceforge.net>',
		'Timothy Kilbourn']
_documenter = 'Christian Faulhammer <opfer@gentoo.org>'
_artists    = 'elogviewer needs a logo, \nartists are welcome to contribute, \nplease contact the author.\nMathias Laurin' 
_appname_    = 'elogviewer'
_version    = '0.5.2'
_website    = 'http://sourceforge.net/projects/elogviewer'
_copyright  = 'Copyright (c) 2006 Mathias Laurin'
_license    = 'GNU General Public License (GPL) version 2'


_LICENSE    = _copyright + '''

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.'''


_description = '''
<b>elogviewer</b> lists all elogs created during emerges of packages from Portage, the package manager of Gentoo Linux.  So all warnings or informational messages generated during an update can be reviewed at one glance.

<tt>man 1 elogviewer</tt> and <tt>man 1 /etc/make.conf</tt> for more informations.

Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.
Jeremy Wickersheimer adapted elogviewer to KDE, some features he added are now imported in elogviewer.
Christian Faulhammer (V-Li) has written the man page.
'''


# Redirect messages to stderr
import sys
sys.stdout = sys.stderr

try:
	import gtk
except:
	print '''
Elogviewer should help you not to miss important information like: 

If you have just upgraded from an older version of python you
will need to run:
	/usr/sbin/python-updater

please do run it and restart elogviewer.
'''
	exit(1)

import os
import portage
if _debug:
	print "Debug mode\n"
	os.chdir("elog/elog")
else:
	try:
		os.chdir(portage.settings["PORT_LOGDIR"])
	except:
		os.chdir("/var/log/portage")
	try:
		os.chdir("./elog")
	except:
		print '''
You need to enable the elog feature by setting at least one of 
	PORTAGE_ELOG_CLASSES="info warn error log"
and
	PORTAGE_ELOG_SYSTEM="save"
in /etc/make.conf


Read /etc/make.conf.example for more information
'''
		exit(1)



filter = {'INFO': True, 'WARN': True, 'ERROR': True, 'LOG': True,
		'preinst': True, 'postinst': True, 'prerm': True, 'postrm': True,
		'unpack': True, 'compile': True, 'setup': True, 'test': True,
		'install': True, 'other': True}


class MainWindow (gtk.Window):
		
	def __init__ (self):
		gtk.Window.__init__ (self, gtk.WINDOW_TOPLEVEL)
		self.set_title( _appname_ )
		self.set_default_size( 800, 600 )


class ScrolledWindow(gtk.ScrolledWindow):
	
	def __init__(self):
		gtk.ScrolledWindow.__init__(self)
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)


import time
class Elog:
	
	def __init__(self, filename):

		itime = '%Y%m%d-%H%M%S.log'
		# DEBUG: otime should be according to gnome pref.
		otime = '%Y-%m-%d %H:%M:%S'

		(c, p, t) = filename.split(':')
		t = time.strptime(t, itime)
		t = time.strftime(otime, t)
		
		self.category = c
		self.package = p
		self.timestamp = t
		self.filename = filename


from glob import glob
from gobject import TYPE_STRING
( CATEGORY, PACKAGE, TIMESTAMP, FILENAME ) = range(4)
class ListStore(gtk.ListStore):

	def __init__(self):
		gtk.ListStore.__init__( self,
				TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_STRING )
		self.set_sort_column_id(TIMESTAMP, gtk.SORT_DESCENDING)

	def populate(self):
		self.clear()
		# BUG #187595 (thank you Radice David)
		self.elog = [Elog(filename) for filename in glob('*:*:*.log')]
		for e in self.elog:
			self.append([e.category, e.package, e.timestamp, e.filename])


class TreeStore(gtk.TreeStore):

	def __init__(self):
		gtk.TreeStore.__init__( self,
				TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_STRING )

	def populate(self):
		self.clear()
		# FIXME (parrot! not here)
		self.elog = [Elog(filename) for filename in glob('*:*:*.log')]
		for e in self.elog:
			# FIXME nothing like C++ algorithms in python?
			# http://www.mono-project.com/GtkSharp_TreeView_Tutorial
			it = self.get_iter_first()
			while True:
				if it is None:
					it = self.append(it, [e.category, None, None, None])
					self.append(it, [None, 
						e.package, e.timestamp, e.filename])
					break
				if self.get_value(it, CATEGORY) == e.category:
					self.append(it, [None, 
						e.package, e.timestamp, e.filename])
					break
				it = self.iter_next(it)


class TreeView(gtk.TreeView):
	
	def __init__(self):
		# FIXME model is not defined here
		gtk.TreeView.__init__(self)

		self.append_column(gtk.TreeViewColumn(
			'Category', gtk.CellRendererText(), text=CATEGORY))
		self.append_column(gtk.TreeViewColumn(
			'Package', gtk.CellRendererText(), text=PACKAGE))
		self.append_column(gtk.TreeViewColumn(
			'Time', gtk.CellRendererText(), text=TIMESTAMP))
		# FIXME next is + elegant but does not work
		#[ c.set_sort_order(gtk.SORT_DESCENCDING) 
		#		for c in self.get_columns() ]
		for c in range(len(self.get_columns())):
			self.get_column(c).set_sort_column_id(c)
		
		self.set_enable_search(True)
		self.set_search_column(PACKAGE)
		#self.get_selection().set_mode(gtk.SELECTION_MULTIPLE)


class CheckButton(gtk.CheckButton):

	def __init__(self, label=None, use_underline=False):
		gtk.CheckButton.__init__(self, label, use_underline)
		self.set_active(True)


class HeaderTable(gtk.Table):

	def __init__(self):
		gtk.Table.__init__(self, 2, 2, True)

		btn_info = CheckButton('INFO')
		btn_warn = CheckButton('WARN')
		btn_error = CheckButton('ERROR')
		btn_log = CheckButton('LOG')

		self.attach(btn_info,  0, 1, 0, 1)
		self.attach(btn_warn,  1, 2, 0, 1)
		self.attach(btn_error, 0, 1, 1, 2)
		self.attach(btn_log,   1, 2, 1, 2)

		# public
		self.btn_info = btn_info
		self.btn_warn = btn_warn
		self.btn_error = btn_error
		self.btn_log = btn_log


class StageTable(gtk.Table):

	def __init__(self):
		gtk.Table.__init__(self, 2, 5, True)

		btn_preinst = CheckButton('preinst')
		btn_postinst = CheckButton('postinst')
		btn_prerm = CheckButton('prerm')
		btn_postrm = CheckButton('postrm')
		btn_unpack = CheckButton('unpack')
		btn_compile = CheckButton('compile')
		btn_setup = CheckButton('setup')
		btn_test = CheckButton('test')
		btn_install = CheckButton('install')
		btn_other = CheckButton('other')

		self.attach(btn_preinst,  0, 1, 0, 1)
		self.attach(btn_postinst, 1, 2, 0, 1)
		self.attach(btn_prerm,    0, 1, 1, 2)
		self.attach(btn_postrm,   1, 2, 1, 2)
		self.attach(btn_unpack,   0, 1, 2, 3)
		self.attach(btn_compile,  1, 2, 2, 3)
		self.attach(btn_setup,    0, 1, 3, 4)
		self.attach(btn_test,     1, 2, 3, 4)
		self.attach(btn_install,  0, 1, 4, 5)
		self.attach(btn_other,    1, 2, 4, 5)

		# public
		self.btn_preinst = btn_preinst
		self.btn_postinst = btn_postinst
		self.btn_prerm = btn_prerm
		self.btn_postrm = btn_postrm
		self.btn_unpack = btn_unpack
		self.btn_compile = btn_compile
		self.btn_setup = btn_setup
		self.btn_test = btn_test
		self.btn_install = btn_install
		self.btn_other = btn_other

class ModelSelector(gtk.HBox):
	'''Two buttons for selecting the model'''

	def __init__(self):
		gtk.HBox.__init__(self)
		self.btn_liststore = gtk.RadioButton(None, 'List')
		self.btn_treeview  = gtk.RadioButton(self.btn_liststore, 'Tree view')
		self.add(self.btn_liststore)
		self.add(self.btn_treeview)


class Buffer(gtk.TextBuffer):

	def __init__(self):
		gtk.TextBuffer.__init__(self)
		self.create_tag('INFO', foreground='darkgreen')
		self.create_tag('WARN', foreground='red')
		self.create_tag('LOG', foreground='black')
		self.create_tag('ERROR', foreground='orange')

	def read(self, selection):
		# FIXME could be improved
		[model, iter] = selection.get_selected()
		if iter is None:
			# no selection
			return
		filename = model.get_value(iter, FILENAME)
		if filename is None:
			# selection of a tree branch
			return
		if _debug:
			print filename
		file_obj = open(filename, 'r')
		try:
			# Parse file
			self.delete(
					self.get_start_iter(),
					self.get_end_iter())
			tags = self.get_tag_table()
			for line in file_obj.read().splitlines():
				it = self.get_end_iter()
				# Read section
				L = line.split(': ')
				if len(L) is 2 and L[0] in filter.keys() and L[1] in filter.keys():
					(h, s) = L
					my_tag = tags.lookup(h)
					self.insert_with_tags(
							self.get_end_iter(),
							h + ' (' + s + ')\n\n', my_tag)
				else:
					if filter[h] and filter[s]:
						# Read body
						self.insert_with_tags(
								self.get_end_iter(),
								line + '\n', my_tag)
		finally:
			file_obj.close()



class TextView(gtk.TextView):

	def __init__(self):
		gtk.TextView.__init__(self)
		self.set_editable(False)
		self.set_cursor_visible(False)
		self.set_wrap_mode(gtk.WRAP_WORD)


class AboutDialog(gtk.AboutDialog):

	def __init__(self):
		gtk.AboutDialog.__init__(self)
		self.set_version( _version )
		self.set_website( _website )
		self.set_authors( _author )
		self.set_artists( [_artists] )
		self.set_copyright( _copyright )
		self.set_documenters( [_documenter, _author] )
		self.set_license( _LICENSE )
		self.run()
		self.destroy()


class Info(gtk.MessageDialog):

	def __init__(self):
		gtk.MessageDialog.__init__(self, 
				None, 0, gtk.MESSAGE_INFO, gtk.BUTTONS_OK, None)
		self.set_markup ( _description )
		self.run()
		self.destroy()


class UIManager(gtk.UIManager):

	def __init__ (self):

		gtk.UIManager.__init__ (self)
		self.add_ui_from_string( '''
		<ui>
		<menubar name="Menubar">
			<menu action="File">
				<menuitem action="Delete"/>
				<menuitem action="Clear"/>
				<menuitem action="Refresh"/>
				<separator/>
				<menuitem action="Quit"/>
			</menu>
			<menu action="Help">
				<menuitem action="Info"/>
					<menuitem action="About"/>
			</menu>
		</menubar>
		<toolbar name="Toolbar">
			<toolitem action="Quit"/>
			<toolitem action="Delete"/>
			<toolitem action="Clear"/>
			<toolitem action="Refresh"/>
		</toolbar>
		</ui>
		''')
		
		# FIXME split
		ag = gtk.ActionGroup('Main')

		ag.add_actions([
			('File', None, 'File'),
			('Help', None, 'Help'),
			('About', None, 'About...', None, None, self.about),
			('Info', None, 'Info', None, None, self.info),
			('Quit', gtk.STOCK_QUIT, 'Quit',   
				'<Control>q', 'Quit <Ctrl+q>', self.quit),
			('Delete', gtk.STOCK_DELETE, 'Delete', 
				'<Control>d', 'Delete selected entry <Ctrl+d>', self.delete),
			('Clear', gtk.STOCK_CLEAR, 'Clear',  
				'<Control>c', 'Clear all <Ctrl+c>', self.clear),
			('Refresh', gtk.STOCK_REFRESH, 'Refresh',
				'<Control>r', 'Refresh <Ctrl+r>', self.refresh)
		])

		self.insert_action_group(ag, 0)

		### Extract widgets
		self.menubar     = self.get_widget('/Menubar')
		self.toolbar     = self.get_widget('/Toolbar')
		self.accel_group = self.get_accel_group()
			
	def about(self, *args):
		AboutDialog()

	def info(self, *args):
		Info()

	# FIXME
	def quit(self, *args):
		print 'quit'

	# FIXME
	def delete(self, *args):
		print 'del'

	# FIXME
	def clear(self, *args):
		print 'clear'

	# FIXME
	def refresh(self, *args):
		print 'refresh'


# FIXME empty statusbar
class Statusbar(gtk.Statusbar):

	def __init__(self):
		gtk.Statusbar.__init__(self)


class Elogviewer(MainWindow):

	def __init__(self):
		# BEGIN GUI
		# Root window
		MainWindow.__init__(self)
		self.connect( 'destroy', lambda w: self.destroy() )

		# Box
		rootbox = gtk.VBox(False, 0)
		self.add(rootbox)
		
		ui = UIManager()
		self.add_accel_group(ui.accel_group)
		rootbox.pack_start(ui.menubar, False)
		rootbox.pack_start(ui.toolbar, False)

		vpaned = gtk.VPaned()
		rootbox.pack_start(vpaned)

		statusbar = Statusbar()
		rootbox.pack_start(statusbar, False)

		eloglist_box = ScrolledWindow()
		eloglist = TreeView()
		flat = ListStore()
		tree = TreeStore()
		eloglist_box.add(eloglist)
		vpaned.pack1(eloglist_box, True)

		elogview_box = ScrolledWindow()
		elogview = TextView()
		buffer = Buffer()
		elogview.set_buffer(buffer)
		elogview_box.add(elogview)

		botrightbox = gtk.VBox(False)
		f_header = HeaderTable()
		f_stage = StageTable()
		modelselector = ModelSelector()
		botrightbox.pack_start(f_header, False)
		botrightbox.pack_start(gtk.HSeparator(), False)
		botrightbox.pack_start(f_stage, False)
		botrightbox.pack_start(gtk.HSeparator(), False)
		botrightbox.pack_start(modelselector, False)

		botbox = gtk.HBox()
		botbox.pack_start(elogview_box)
		botbox.pack_start(botrightbox, False)
		vpaned.pack2(botbox, True)

		self.show_all()
		# END GUI

		# connections
		eloglist.get_selection().connect_object(
				'changed', elogview.get_buffer().read, \
						eloglist.get_selection())
		modelselector.btn_treeview.connect('toggled', self.set_model)
		# connect the filter
		f_header.btn_info.connect('toggled', self.filter)
		f_header.btn_warn.connect('toggled', self.filter)
		f_header.btn_error.connect('toggled', self.filter)
		f_header.btn_log.connect('toggled', self.filter)
		
		f_stage.btn_preinst.connect('toggled', self.filter)
		f_stage.btn_postinst.connect('toggled', self.filter)
		f_stage.btn_prerm.connect('toggled', self.filter)
		f_stage.btn_postrm.connect('toggled', self.filter)
		f_stage.btn_unpack.connect('toggled', self.filter)
		f_stage.btn_compile.connect('toggled', self.filter)
		f_stage.btn_setup.connect('toggled', self.filter)
		f_stage.btn_test.connect('toggled', self.filter)
		f_stage.btn_install.connect('toggled', self.filter)
		f_stage.btn_other.connect('toggled', self.filter)

		# public
		self.eloglist = eloglist
		self.tree = tree
		self.flat = flat
		self.buffer = buffer
		self.elogview = elogview

		# default model flat or tree
		eloglist.set_model(flat)


		# populate
		eloglist.get_model().populate()

	def destroy(self):
		gtk.main_quit()
	
	def set_model(self, is_treeview):
		if is_treeview.get_active():
			self.eloglist.set_model(self.tree)
		else:
			self.eloglist.set_model(self.flat)
		self.eloglist.get_model().populate()
	
	def filter(self, chk_btn):
		filter[chk_btn.get_label()] = chk_btn.get_active()
		# update
		self.buffer.read(self.eloglist.get_selection())


def main():
	gtk.main()
	return 0


if __name__ == "__main__":
	Elogviewer()
	main()

# Refs
# http://www.javaworld.com/jw-07-1999/jw-07-toolbox.html
# http://www.pygtk.org/pygtk2reference/
# http://docs.python.org/
# Python Cookbook, 2nd ed., O'Reilly
# http://www.mono-project.com/GtkSharp_TreeView_Tutorial

# EOF
