#!/usr/bin/env python

_debug         = True

_author     = 'Mathias Laurin <mathias_laurin@users.sourceforge.net>'
_documenter = 'Christian Faulhammer <opfer@gentoo.org>'
_artists    = 'elogviewer needs a logo, \nartists are welcome to contribute, \nplease contact the author.\n' + _author
_appname_    = 'elogviewer'
_version    = '0.5.1'
_website    = 'http://sourceforge.net/projects/elogviewer'
_copyright  = 'Copyright (c) 2006 ' + _author
_license    = 'GNU General Public License (GPL) version 2'


_LICENSE    = _copyright + '''

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.'''


_description = '''
elogviewer lists all elogs created during emerges of packages from Portage, 
the package manager of Gentoo Linux.  So all warnings or informational 
messages generated during an update can be reviewed at one glance.

man 1 elogviewer and man 1 /etc/make.conf for more informations.

Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.
Jeremy Wickersheimer adapted elogviewer to KDE, some features he added were
back ported in elogviewer.
Christian Faulhammer (V-Li) has written the man page.
'''


try:
	import pygtk
	pygtk.require('2.0')
except:
	print "Please run: emerge --sync && emerge pygtk"

import gtk
from   gobject  import TYPE_STRING, TYPE_PYOBJECT
import portage
import os
import time
import re

### Redirect any message from sdtout to stderr
from sys     import stdout, stderr
stdout = stderr

if _debug:
	print 'Running debug mode'
	os.chdir("elog")
else:
	try:
		os.chdir(portage.settings["PORT_LOGDIR"])
	except:
		os.chdir("/var/log/portage")
	try:
		os.chdir("./elog")
	except:
		print '''
Please install the elog feature as explained in the ebuild and
in /etc/make.conf.example
you should have at least one of 
	PORTAGE_ELOG_CLASSES="info warn error log"
and
	PORTAGE_ELOG_SYSTEM="save"
in your /etc/make.conf
		'''


(
	CATEGORY_COLUMN,
	PACKAGE_COLUMN,
	TIMESTAMP_COLUMN,
	FILENAME_COLUMN
) = range(4)


class Header:

		def __init__(self, name, color='black', is_section=False, is_active=True):
			self.name = name
			self.color = color
			self.is_section = is_section
			self.is_active = is_active


class HeaderList:
		'''Initialize the values for the filter '''
		def __init__(self):
			self.INFO = Header('INFO', 'darkgreen', True)
			self.WARN = Header('WARN', 'red', True)
			self.ERROR= Header('ERROR', 'orange', True)
			self.LOG  = Header('LOG', 'black', True)

			self.preinst = Header('preinst')
			self.postinst= Header('postinst')
			self.postrm  = Header('postrm')
			self.prerm   = Header('prerm')
			self.unpack  = Header('unpack')
			self.compile = Header('compile')
			self.setup   = Header('setup')
			self.test    = Header('test')
			self.install = Header('install')
			self.other   = Header('other')

		# Call the dictionary dictionary
		# I love python
		def keys(self):
			return self.__dict__.keys()

		def values(self):
			return self.__dict__.values()

		def is_active(self, name):
			return self.__dict__[name].is_active

		def section(self):
			list = []
			for value in self.__dict__.values():
				if value.is_section:
					list.append(value)
			return list

		def stage(self):
			list = []
			for value in self.__dict__.values():
				if not value.is_section:
					list.append(value)
			return list


class LogEntry:

		def __init__ (self, filename='c:p:t.log'):
			intimeformat  = '%Y%m%d-%H%M%S.log'
			outtimeformat = '%Y-%m-%d %H:%M:%S'

			(c, p, t) = re.split(':', str(filename))
			t = time.strptime (t, intimeformat)
			t = time.strftime (outtimeformat, t)

			self.category = c
			self.package  = p
			self.timestamp= t
			self.filename = filename


class ScrolledWindow (gtk.ScrolledWindow):

	def __init__ (self, child):
		gtk.ScrolledWindow.__init__ (self)
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		self.add (child)


#
#	File list
#
class Model:

		def __init__ (self):
			liststore = gtk.ListStore (TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_PYOBJECT)
			liststore.set_sort_column_id(TIMESTAMP_COLUMN, gtk.SORT_DESCENDING)
			self.liststore = liststore
			
			treestore = gtk.TreeStore (TYPE_STRING, TYPE_STRING, TYPE_STRING, TYPE_PYOBJECT)
			self.treestore = treestore

		def populate (self):
			self.treestore.clear()
			self.liststore.clear()
			for filename in os.listdir(os.getcwd()):
				log  = LogEntry(filename)
				### Liststore
				self.liststore.append([log.category, log.package, 
								log.timestamp, log.filename])
				### Treestore looks simple now.
				iter = self.treestore.get_iter_first()
				_loop = True
				while _loop:
					if iter is None:
						_newcategory = True
						_loop = False
					else:
						category = self.treestore.get_value(iter, CATEGORY_COLUMN)
						if category == log.category:
							self.treestore.append(iter, ['', 
									log.package, log.timestamp, log.filename])
							_newcategory = False
							_loop = False
						iter = self.treestore.iter_next(iter) 
				if _newcategory:
					iter = self.treestore.append(None, [log.category, '', '', ''])
					self.treestore.append(iter, ['', 
							log.package, log.timestamp, log.filename])


class ModelSelector (gtk.HBox):

		def __init__ (self, set_treeview):
			gtk.HBox.__init__(self)
			liststore = gtk.RadioButton(None, 'List')
			treeview  = gtk.RadioButton(liststore, 'Tree view')
			treeview.connect('toggled', set_treeview, True)
			liststore.connect('toggled', set_treeview,  False)
			self.add(liststore)
			self.add(treeview)


class FileList (gtk.TreeView):

		def __init__ (self, selection_handler):

			col_headers = ['Category', 'Package', 'Timestamp']
			self.model  = Model()
			gtk.TreeView.__init__ (self)
			self.set_enable_search(True)
			self.set_search_column(PACKAGE_COLUMN)
			#self.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

			for c in range(len(col_headers)):
				cell = gtk.CellRendererText()
				col  = gtk.TreeViewColumn(col_headers[c], cell, text=c)
				col.set_sort_column_id(c)
				self.append_column(col)

			# Selection handler
			self.get_selection().connect_object('changed', selection_handler, None)

			# NOTE: very likely, populate() should be here!
			# Export
			self.populate = self.model.populate

		def set_treeview(self, treeview):
			if treeview:
				model = self.model.treestore
			else:
				model = self.model.liststore
			self.set_model(model)

		def get_nfiles(self):
			return len(self.model.liststore)


#
#	TextView
#
class Buffer (gtk.TextBuffer):
		
		def __init__ (self, headerlist):
			gtk.TextBuffer.__init__ (self)
			self.set_text('No selection')
			for n in headerlist.section():
				tag = self.create_tag(n.name, foreground=n.color)


class LogView (gtk.TextView):

		def __init__ (self, headerlist):
			gtk.TextView.__init__ (self)
			self.set_editable (False)
			self.set_cursor_visible (False)
			self.set_wrap_mode (gtk.WRAP_WORD)

			self.buffer = Buffer(headerlist)
			self.set_buffer (self.buffer)
			
			# WARNING: potentially dangerous to have the regexp matching over 
			# stages
			self.reheaderlist= self.__make_re_list(headerlist.keys())
			self.headerlist  = headerlist

		def __make_re_list (self, list):
			relist = 'empty'
			for n in list:
				if relist == 'empty':
					relist = n
				else:
						relist = relist + '|' + n
				relist = relist + ': '
			relist = re.compile(relist)
			return relist

		def __strip_nl (self, line):
			return re.match(r'^([^\\\n]*)', line).group(1)

		def set_text (self, filename):
			### Read the file
			file      = open(filename, 'r')
			firstline = True
			for readline in file:
				readline = self.__strip_nl(readline)
				### is section?
				if self.reheaderlist.match(readline):
					(section, stage) = readline.split(': ')
					if firstline:
						self.buffer.set_text('')
						firstline = False
					else:
						self.buffer.insert_at_cursor ('\n')
					
					line = '%s (%s)\n' % (section, stage)
					iter = self.buffer.get_end_iter()
					self.buffer.insert_with_tags_by_name(iter, line, section)

				### filter content?
				elif self.headerlist.is_active(section) and \
							self.headerlist.is_active(stage):
						line = '%s\n' % readline
						iter = self.buffer.get_end_iter()
						self.buffer.insert_with_tags_by_name(iter, line, section)


#
#	Filter
#
class Filter(gtk.Table):

		def __init__ (self, list, selection_changed):
			### NOTE: won't work on odd number of stage/header
			### fix it if ever it happens someday:
			### a dummy box that is not shown would do
			tx = len(list)/2
			ty = 2
			gtk.Table.__init__ (self, tx, ty, True)

			self.selection_changed = selection_changed

			btn = {}
			row = 0
			col = 0

			for hlist in list:
				btn[hlist.name] = gtk.CheckButton(hlist.name, False)
				btn[hlist.name].set_active(hlist.is_active)
				btn[hlist.name].connect('toggled', self.toggle, hlist)
				self.attach(btn[hlist.name], col, col+1, row, row+1)
				col += 1
				if col == ty:
					col  = 0
					row += 1

		def toggle(self, btn, header):
			header.is_active = not header.is_active
			### DEBUG not so elegant
			self.selection_changed()


#
#	User interface
#
class Actions(gtk.UIManager):

		def __init__ (self, delete, clear, refresh, quit):
			gtk.UIManager.__init__ (self)

			ui = '''<ui>
			<menubar name="Menubar">
				<menu action="File">
					<menuitem action="Delete"/>
					<menuitem action="Clear"/>
					<menuitem action="Refresh"/>
					<separator/>
					<menuitem action="Quit"/>
				</menu>
				<menu action="Help">
					<menuitem action="Info"/>
					<menuitem action="About"/>
				</menu>
			</menubar>
			<toolbar name="Toolbar">
				<toolitem action="Quit"/>
				<toolitem action="Delete"/>
				<toolitem action="Clear"/>
				<toolitem action="Refresh"/>
			</toolbar>
			</ui>'''

			action_group = gtk.ActionGroup('Main')
			action_group.add_actions([
			('File',    None, '_File'),
			('Help',    None, '_Help'),
			('About',   None, '_About...', None, None, self.about_box),
			('Info',    None, '_Info',     None, None, self.info_box),
			('Quit',    gtk.STOCK_QUIT,   '_Quit',   'q', 'Quit', quit),
			('Delete',  gtk.STOCK_DELETE, '_Delete', 'd', 'Delete selected entry', 
					delete),
			('Clear',   gtk.STOCK_CLEAR,  '_Clear',  'c', 'Clear all', clear),
			('Refresh', gtk.STOCK_REFRESH,'_Refresh','r', 'Refresh', refresh)
			])
			
			self.insert_action_group(action_group, 0)
			self.add_ui_from_string(ui)

			### Extract widgets
			self.menubar     = self.get_widget('/Menubar')
			self.toolbar     = self.get_widget('/Toolbar')
			self.accel_group = self.get_accel_group()

		def about_box (self, *args):
			d = gtk.AboutDialog()
			d.set_version( _version )
			d.set_website( _website )
			d.set_authors( [_author, 'Timothy Kilbourn (nmbrthry) has written the first version of elogviewer.'] )
			d.set_artists( [_artists] )
			d.set_copyright( _copyright )
			d.set_documenters( [_documenter, _author] )
			d.set_license( _LICENSE )
			d.run()
			d.destroy()

		def info_box (self, *args):
			d = gtk.MessageDialog(None, 0, gtk.MESSAGE_INFO, gtk.BUTTONS_OK, None)
			d.set_markup ( _description )
			d.run()
			d.destroy()


#
#	Statusbar
#
class Statusbar (gtk.Statusbar):

		def __init__ (self):
			gtk.Statusbar.__init__(self)

		def update(self, text):
			self.push(0, text)


#
#	Main program
#
class Elogviewer (gtk.Window):
		
		def destroy (self, *args):
			gtk.main_quit()
	
		def __init__ (self):
			# Initialize main window
			gtk.Window.__init__ (self, gtk.WINDOW_TOPLEVEL)
			self.set_title( _appname_ )
			self.connect( "destroy", lambda w: self.destroy() )
			self.set_default_size( 800, 600 )
			self.show()

			# Get list and properties of headers
			headerlist = HeaderList()
			section = headerlist.section()
			stage   = headerlist.stage()

			# Initialize widgets
			actions  = Actions(self.delete, self.clear, self.refresh, self.destroy)
			f_sectionbox = Filter(section, self.selection_changed)
			f_stagebox   = Filter(stage,   self.selection_changed)
			pane     = gtk.VPaned()
			filelist = FileList(self.selection_changed)
			logview  = LogView(headerlist)
			statusbar= Statusbar()
			modelselector = ModelSelector(self.set_treeview)
			
			# Accelerators
			self.add_accel_group(actions.accel_group)

			# Box for packing widgets
			rootbox  = gtk.VBox (False, 0)
			self.add(rootbox)
			self.rootbox = rootbox

			rootbox.pack_start(actions.menubar, False)
			rootbox.pack_start(actions.toolbar, False)
			rootbox.pack_start(pane)
			rootbox.pack_start(statusbar, False)
			rootbox.show()

			# Fill main window (double pane)
			scfilelist = ScrolledWindow(filelist)
			pane.pack1  (scfilelist, True)
			#
			_botbox    = gtk.HBox()
			sclogview  = ScrolledWindow(logview)
			_botbox.pack_start(sclogview, True)
			#
			_filterbox = gtk.VBox(False)
			_filterbox.pack_start(f_sectionbox, False)
			_filterbox.pack_start(gtk.HSeparator(), False)
			_filterbox.pack_start(f_stagebox, False)
			_filterbox.pack_start(gtk.HSeparator(), False)
			_filterbox.pack_start(modelselector, False)
			#
			_botbox.pack_start(_filterbox, False)
			pane.pack2  (_botbox, True)
			#
			pane.show_all()

			# Show status bar
			statusbar.show()

			# Export
			self.filelist  = filelist
			self.selection = filelist.get_selection()
			self.logview   = logview
			self.statusbar = statusbar

			# Populate!
			filelist.populate()
			if not _debug:
				self.selection.select_path(0)
			# Select a model
			filelist.set_treeview(False)
			print filelist.get_nfiles()

		### Actions
		def set_treeview (self, widget, bool):
			self.filelist.set_treeview(bool)

		def __get_filename (self, *args):
			# return (filename, model, iter)
			[model, iter] = self.selection.get_selected()
			if iter is None:
				if _debug:
					print 'No selection'
				return False, False, False
			filename = model.get_value(iter, FILENAME_COLUMN)
			if filename is '':
				if _debug:
					print 'Root selected', model.get_path(iter)
				return 'Root', model, iter
			return filename, model, iter


		def selection_changed (self, *args):
			[filename, model, iter] = self.__get_filename()
			if filename is False:
				# no selection
				return
			if filename is 'Root':
				# root selected, invalid filename
				return

			self.logview.set_text(filename)
			# Collect other infos for the statusbar
			tot_files = model.iter_n_children(None)
			sel_file  = model.get_path(iter)[0] + 1
			statusbartext = str(sel_file) + '/' + str(tot_files) + ' file: ' + filename
			self.statusbar.update(statusbartext)

		# NOTE: delete(self.selection) should be in filelist
		'''delete(selection) [RETURN selection]'''
		def delete (self, *args):
			[filename, model, iter] = self.__get_filename()
			if filename is False:
				return

			# Get path before removing file
			path     = model.get_path(iter)

			model.remove (iter)
			if _debug:
				print filename
			else:
				os.remove (filename)

			# Select next entry
			if model.iter_is_valid(iter):
				self.selection.select_iter(iter)
			else:
				test = len(path)
				if test == 1:
					# ListStore: end of the list
					# select last but one unless list empty
					newpath = (path[0]-1,)
					if newpath != (-1,):
						self.selection.select_path(newpath)
				else:
					# Treeview: end of branch
					if _debug:
						print path
					if path[1] != 0:
						# Not the last element (last is not first)
						# select previous one
						newpath = (path[0],path[1]-1)
						self.selection.select_path(newpath)
					else:
						# Last is first, remove tree and select prev one
						iter    = model.get_iter(path[0],)
						model.remove (iter)
						newpath = (path[0]-1,)
						if newpath == (-1,):
							try:
								self.selection.select_path(newpath)
							except:
								# Tree is empty
								pass
						else:
							self.selection.select_path(newpath)

		def clear (self, *args):
			button = gtk.BUTTONS_YES_NO
			dialog = gtk.MessageDialog(None, 0, gtk.MESSAGE_WARNING, button, 
				"The whole elog directory is going to be wiped out.\
				Are you sure you want to proceed?")
			clear = dialog.run()
			dialog.destroy()

			if clear == gtk.RESPONSE_YES:
				self.selection.select_path(0)
				while self.selection.path_is_selected(0):
					self.delete()


		def refresh(self, *args):
			self.filelist.populate()


def main():
		gtk.main()
		return 0


if __name__ == "__main__":
		Elogviewer()
		main()

### Refs
# http://www.javaworld.com/jw-07-1999/jw-07-toolbox.html
# http://www.pygtk.org/pygtk2reference/
# http://docs.python.org/
